THERE_BE_DRAGONS_HERE
FileDoesNotExist: File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/analysis/tools/moose/analysis/output/a-1392818086/test-MooseDependencies.st
19 February 2014 3:00:20.785388 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileHandle>>streamError
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
		writable: 	false
		id: 	nil


FileHandle>>readStream
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
		writable: 	false
		id: 	nil


FileSystem>>readStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'Users' / 'caracciolo' / 'GoogleDrive' / '_WORK' / 'Project...etc...
	Receiver's instance variables: 
		workingDirectory: 	Path / 'Users' / 'caracciolo' / 'GoogleDrive' / '_WORK' / 'Pr...etc...
		store: 	a MacStore


FileReference>>readStream
	Receiver: File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/analysis/tools/moose...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'GoogleDrive' / '_WORK' / 'Projects' / 'n...etc...


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/analysis/tools/moose...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :stream | 
self
	handleErrorsDuring: [ 
		codeImporter := CodeImporte...etc...
		stream: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'GoogleDrive' / '_WORK' / 'Projects' / 'n...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	nil
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'analysis/output/a-1392818086/test-MooseDependencies.st'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
FileHandle>>streamError
FileHandle>>readStream
FileSystem>>readStreamOn:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890337/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 10:58:59.663 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 10:59:06.00697 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 11:00:13.26861 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 11:02:11.593611 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 11:51:28.98036 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 11:57:27.912665 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 11:58:52.411087 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 11:59:10.09708 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:08:10.83283 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:08:32.37874 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:10:36.516038 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:11:35.957486 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:12:04.995485 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:12:23.31522 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:12:51.299546 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:12:58.502596 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:15:36.714131 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:15:52.244889 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:16:30.416624 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:17:23.316831 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:17:50.566266 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:18:37.682579 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:18:51.907516 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:19:48.985078 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:20:17.842653 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:20:34.852544 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:21:05.826426 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 12:21:33.201462 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 3:58:47.24316 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:00:03.096464 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:08:25.853359 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:09:19.472909 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:22:01.236599 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:26:11.72995 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:27:42.314966 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:28:13.817896 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:28:45.073835 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:29:19.340378 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:43:38.522009 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392890344/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
20 February 2014 4:44:06.089227 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varModel |
	mooseModel := Moo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392912756/DIMooseDependencies.st
===============================================================================
SyntaxErrorNotification
20 February 2014 5:12:40.547632 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'End of statement list encounted ->'
		location: 	807
		code: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...
		fileReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROT...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'End of statement list encounted'
		location: 	807


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := ...etc...
		doitFlag: 	false
		errorString: 	'End of statement list encounted'
		location: 	807
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'End of statement list encounted'
		errorNode: 	nil
		errorMessage: 	'End of statement list encounted'
		errorPosition: 	807
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| found |
)
		statements: 	an OrderedCollection(RBAssignmentNode(found := false) RBMessageNode...etc...
		return: 	true
		periods: 	an OrderedCollection(629)
		returnPosition: 	nil
		node: 	RBMessageNode(c outgoingInvocations
	do: [ :i | 
		i to
			ifNotNil: [ 
	...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| found |
)
		temps: 	an OrderedCollection(RBTemporaryNode(found))
		leftBar: 	608
		rightBar: 	614
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser>>parseBlock
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		position: 	599
		node: 	RBBlockNode([ :c | 
| found |
 ])
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseUnaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseBinaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseKeywordMessageWith:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	RBMessageNode(varModel allClasses)
		args: 	an OrderedCollection()
		isKeyword: 	false
		keywords: 	an OrderedCollection( RBKeywordToken('do:'))
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseKeywordMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseCascadeMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		receiver: 	nil
		messages: 	nil
		semicolons: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseAssignment
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		position: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varModel |
...etc...
		statements: 	an OrderedCollection(RBAssignmentNode(mooseModel := MooseModel new)...etc...
		return: 	false
		periods: 	an OrderedCollection(81 163 203 255 271 428 572)
		returnPosition: 	nil
		node: 	RBAssignmentNode(varModel := MooseModel root first allNamespaces
	detect:...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varModel |...etc...
		temps: 	an OrderedCollection(RBTemporaryNode(stream) RBTemporaryNode(mooseModel)...etc...
		leftBar: 	1
		rightBar: 	50
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moo...etc...
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moos...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moo...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Moo...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varModel | 
mooseModel := MooseM...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varModel | 
mooseModel := Mo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varModel...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varModel | ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varMo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser>>parseBlock
RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
RBExplicitVariableParser(RBParser)>>parseUnaryMessage
RBExplicitVariableParser(RBParser)>>parseBinaryMessage
RBExplicitVariableParser(RBParser)>>parseKeywordMessageWith:
RBExplicitVariableParser(RBParser)>>parseKeywordMessage
RBExplicitVariableParser(RBParser)>>parseCascadeMessage
RBExplicitVariableParser(RBParser)>>parseAssignment
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser(RBParser)>>parseStatements:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392912896/DIMooseDependencies.st
===============================================================================
SyntaxErrorNotification
20 February 2014 5:14:59.60813 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'End of statement list encounted ->'
		location: 	1122
		code: 	'| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...
		fileReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROT...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'End of statement list encounted'
		location: 	1122


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varService varModel varSoc...etc...
		doitFlag: 	false
		errorString: 	'End of statement list encounted'
		location: 	1122
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'End of statement list encounted'
		errorNode: 	nil
		errorMessage: 	'End of statement list encounted'
		errorPosition: 	1122
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| found |
)
		statements: 	an OrderedCollection(RBAssignmentNode(found := false) RBMessageNode...etc...
		return: 	true
		periods: 	an OrderedCollection(944)
		returnPosition: 	nil
		node: 	RBMessageNode(c outgoingInvocations
	do: [ :i | 
		i to
			ifNotNil: [ 
	...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| found |
)
		temps: 	an OrderedCollection(RBTemporaryNode(found))
		leftBar: 	923
		rightBar: 	929
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser>>parseBlock
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		position: 	914
		node: 	RBBlockNode([ :c | 
| found |
 ])
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseUnaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseBinaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseKeywordMessageWith:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	RBMessageNode(varModel allClasses)
		args: 	an OrderedCollection()
		isKeyword: 	false
		keywords: 	an OrderedCollection( RBKeywordToken('do:'))
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseKeywordMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseCascadeMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		receiver: 	nil
		messages: 	nil
		semicolons: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseAssignment
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		position: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varService ...etc...
		statements: 	an OrderedCollection(RBAssignmentNode(mooseModel := MooseModel new)...etc...
		return: 	false
		periods: 	an OrderedCollection(102 184 224 276 292 449 597 741 887)
		returnPosition: 	nil
		node: 	RBAssignmentNode(varSocial := MooseModel root first allNamespaces
	detect...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varService...etc...
		temps: 	an OrderedCollection(RBTemporaryNode(stream) RBTemporaryNode(mooseModel)...etc...
		leftBar: 	1
		rightBar: 	71
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser>>parseBlock
RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
RBExplicitVariableParser(RBParser)>>parseUnaryMessage
RBExplicitVariableParser(RBParser)>>parseBinaryMessage
RBExplicitVariableParser(RBParser)>>parseKeywordMessageWith:
RBExplicitVariableParser(RBParser)>>parseKeywordMessage
RBExplicitVariableParser(RBParser)>>parseCascadeMessage
RBExplicitVariableParser(RBParser)>>parseAssignment
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser(RBParser)>>parseStatements:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392913000/DIMooseDependencies.st
===============================================================================
SyntaxErrorNotification
20 February 2014 5:16:43.818613 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'End of statement list encounted ->'
		location: 	1122
		code: 	'| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...
		fileReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROT...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'End of statement list encounted'
		location: 	1122


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varService varModel varSoc...etc...
		doitFlag: 	false
		errorString: 	'End of statement list encounted'
		location: 	1122
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'End of statement list encounted'
		errorNode: 	nil
		errorMessage: 	'End of statement list encounted'
		errorPosition: 	1122
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| found |
)
		statements: 	an OrderedCollection(RBAssignmentNode(found := false) RBMessageNode...etc...
		return: 	true
		periods: 	an OrderedCollection(944)
		returnPosition: 	nil
		node: 	RBMessageNode(c outgoingInvocations
	do: [ :i | 
		i to
			ifNotNil: [ 
	...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| found |
)
		temps: 	an OrderedCollection(RBTemporaryNode(found))
		leftBar: 	923
		rightBar: 	929
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser>>parseBlock
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		position: 	914
		node: 	RBBlockNode([ :c | 
| found |
 ])
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseUnaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseBinaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseKeywordMessageWith:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	RBMessageNode(varModel allClasses)
		args: 	an OrderedCollection()
		isKeyword: 	false
		keywords: 	an OrderedCollection( RBKeywordToken('do:'))
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseKeywordMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseCascadeMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		receiver: 	nil
		messages: 	nil
		semicolons: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseAssignment
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		position: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varService ...etc...
		statements: 	an OrderedCollection(RBAssignmentNode(mooseModel := MooseModel new)...etc...
		return: 	false
		periods: 	an OrderedCollection(102 184 224 276 292 449 597 741 887)
		returnPosition: 	nil
		node: 	RBAssignmentNode(varSocial := MooseModel root first allNamespaces
	detect...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varService...etc...
		temps: 	an OrderedCollection(RBTemporaryNode(stream) RBTemporaryNode(mooseModel)...etc...
		leftBar: 	1
		rightBar: 	71
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser>>parseBlock
RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
RBExplicitVariableParser(RBParser)>>parseUnaryMessage
RBExplicitVariableParser(RBParser)>>parseBinaryMessage
RBExplicitVariableParser(RBParser)>>parseKeywordMessageWith:
RBExplicitVariableParser(RBParser)>>parseKeywordMessage
RBExplicitVariableParser(RBParser)>>parseCascadeMessage
RBExplicitVariableParser(RBParser)>>parseAssignment
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser(RBParser)>>parseStatements:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392913152/DIMooseDependencies.st
===============================================================================
SyntaxErrorNotification
20 February 2014 5:19:16.221187 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'End of statement list encounted ->'
		location: 	1122
		code: 	'| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...
		fileReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROT...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'End of statement list encounted'
		location: 	1122


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varService varModel varSoc...etc...
		doitFlag: 	false
		errorString: 	'End of statement list encounted'
		location: 	1122
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'End of statement list encounted'
		errorNode: 	nil
		errorMessage: 	'End of statement list encounted'
		errorPosition: 	1122
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| found |
)
		statements: 	an OrderedCollection(RBAssignmentNode(found := false) RBMessageNode...etc...
		return: 	true
		periods: 	an OrderedCollection(944)
		returnPosition: 	nil
		node: 	RBMessageNode(c outgoingInvocations
	do: [ :i | 
		i to
			ifNotNil: [ 
	...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| found |
)
		temps: 	an OrderedCollection(RBTemporaryNode(found))
		leftBar: 	923
		rightBar: 	929
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser>>parseBlock
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		position: 	914
		node: 	RBBlockNode([ :c | 
| found |
 ])
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseUnaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseBinaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseKeywordMessageWith:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	RBMessageNode(varModel allClasses)
		args: 	an OrderedCollection()
		isKeyword: 	false
		keywords: 	an OrderedCollection( RBKeywordToken('do:'))
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseKeywordMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseCascadeMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		receiver: 	nil
		messages: 	nil
		semicolons: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseAssignment
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		position: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varService ...etc...
		statements: 	an OrderedCollection(RBAssignmentNode(mooseModel := MooseModel new)...etc...
		return: 	false
		periods: 	an OrderedCollection(102 184 224 276 292 449 597 741 887)
		returnPosition: 	nil
		node: 	RBAssignmentNode(varSocial := MooseModel root first allNamespaces
	detect...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varService...etc...
		temps: 	an OrderedCollection(RBTemporaryNode(stream) RBTemporaryNode(mooseModel)...etc...
		leftBar: 	1
		rightBar: 	71
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseStatements:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($()
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varService varModel varSocial ...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	RBBlockNode([ :c | 
| found |
 ])


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varService varModel varSocial...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial | ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser>>parseBlock
RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
RBExplicitVariableParser(RBParser)>>parseUnaryMessage
RBExplicitVariableParser(RBParser)>>parseBinaryMessage
RBExplicitVariableParser(RBParser)>>parseKeywordMessageWith:
RBExplicitVariableParser(RBParser)>>parseKeywordMessage
RBExplicitVariableParser(RBParser)>>parseCascadeMessage
RBExplicitVariableParser(RBParser)>>parseAssignment
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser(RBParser)>>parseStatements:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "allClasses" is nil
20 February 2014 5:23:00.973372 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

UndefinedObject(Object)>>doesNotUnderstand: #allClasses
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	allClasses
		exception: 	MessageNotUnderstood: receiver of "allClasses" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'varModel allClasses do: [ :c | 
	|found|
	found:=false. 	
	c o...etc...
		itsSelection: 	a Text for 'varModel allClasses do: [ :c | 
	|found|
	found:=fals...etc...
		itsSelectionString: 	'varModel allClasses do: [ :c | 
	|found|
	found:=false. 	
...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(893 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(893 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(893 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(893 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	1
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(843841536)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(191102976)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(191102976)
	Receiver's instance variables: 
		timeStamp: 	182597
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(96@404)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(191102976)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(122@454) corner: (138@470)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(122@454) corner: (138@470)
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(191102976)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(130@463) mouseOver nil nil]
		targetOffset: 	(0@240)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 176137 130 463 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1448@1166)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(800587776) an Imag...etc...
		fullBounds: 	(0@0) corner: (1448@1166)
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #allClasses
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "," is nil
20 February 2014 5:23:16.995215 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

UndefinedObject(Object)>>doesNotUnderstand: #,
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	, 'fail: Model must DependOn(Util)'
		exception: 	MessageNotUnderstood: receiver of "," is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

DoIt
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ found := true ] ] ].
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	false
		c: 	DailyMenuplan in com::ese2013::mub::model (Class)
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::ese2013...etc...
	Arguments and temporary variables: 
		aBlock: 	DoIt
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::e...etc...
		firstIndex: 	1
		lastIndex: 	7


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	' varUtil := MooseModel root first allNamespaces detect: [ :n |...etc...
		itsSelection: 	a Text for ' varUtil := MooseModel root first allNamespaces detec...etc...
		itsSelectionString: 	' varUtil := MooseModel root first allNamespaces detect: [ ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'co...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(298 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(298 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(298 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(298 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	1
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(843841536)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(191102976)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(191102976)
	Receiver's instance variables: 
		timeStamp: 	198629
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-167@147)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(191102976)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(-133@206) corner: (-117@222)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(191102976)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(-133@206) mouseOver nil nil]
		targetOffset: 	(50@410)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 197862 -133 206 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #,
DoIt
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ found := true ] ] ].
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "," is nil
20 February 2014 5:23:37.227958 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

UndefinedObject(Object)>>doesNotUnderstand: #,
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	, 'fail: Model must DependOn(Util)'
		exception: 	MessageNotUnderstood: receiver of "," is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

DoIt
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ found := true ] ] ].
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	false
		c: 	DailyMenuplan in com::ese2013::mub::model (Class)
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::ese2013...etc...
	Arguments and temporary variables: 
		aBlock: 	DoIt
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::e...etc...
		firstIndex: 	1
		lastIndex: 	7


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'
 varUtil := MooseModel root first allNamespaces detect: [ :n ...etc...
		itsSelection: 	a Text for '
 varUtil := MooseModel root first allNamespaces dete...etc...
		itsSelectionString: 	'
 varUtil := MooseModel root first allNamespaces detect: [...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'co...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(297 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(297 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(297 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(297 to: 1213)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	1
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(843841536)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(191102976)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(191102976)
	Receiver's instance variables: 
		timeStamp: 	218858
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-86@120)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1380@1028)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1380@1028)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(191102976)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(-52@179) corner: (-36@195)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(191102976)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(-52@179) mouseOver nil nil]
		targetOffset: 	(50@404)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 217954 -52 179 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #,
DoIt
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ found := true ] ] ].
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
20 February 2014 5:24:19.163218 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

[ :i | 
i to
	ifNotNil: [ 
		| targetNS |
		targetNS := i to first belongsTo belongsTo.
		targetNS = varUtil
			ifTrue: [ self halt ] ] ] in [ :c | 
| found |
found := false.
c outgoingInvocations
	do: [ :i | 
		i to
			ifNotNil: [ 
				| targetNS |
				targetNS := i to first belongsTo belongsTo.
				targetNS = varUtil
					ifTrue: [ self halt ] ] ].
found
	ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		c: 	Model in com::ese2013::mub::model (Class)
		found: 	false
		i: 	saveFavorites -> dataSource#storeFavorites(mensas) (Invocation)
		targetNS: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(init -> #ModelCreationTask(menuManager,dataSource,this) (Invocation) ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :i | 
i to
	ifNotNil: [ 
		| targetNS |
		targetNS := i to first belo...etc...
		index: 	35
	Receiver's instance variables: 
		array: 	an Array(init -> #ModelCreationTask(menuManager,dataSource,this) (Invoca...etc...
		firstIndex: 	1
		lastIndex: 	37


[ :c | 
| found |
found := false.
c outgoingInvocations
	do: [ :i | 
		i to
			ifNotNil: [ 
				| targetNS |
				targetNS := i to first belongsTo belongsTo.
				targetNS = varUtil
					ifTrue: [ self halt ] ] ].
found
	ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		c: 	Model in com::ese2013::mub::model (Class)
		found: 	false
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::ese2013...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :c | 
| found |
found := false.
c outgoingInvocations
	do: [ :i | 
		...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::e...etc...
		firstIndex: 	1
		lastIndex: 	7


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'
result := ''''.   
varUtil := MooseModel root first allNamesp...etc...
		itsSelection: 	a Text for '
result := ''''.   
varUtil := MooseModel root first ...etc...
		itsSelectionString: 	'
result := ''''.   
varUtil := MooseModel root first allNa...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		dete...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(281 to: 1209)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(281 to: 1209)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1047)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1047)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(281 to: 1209)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(281 to: 1209)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	11
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(843841536)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(191102976)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1047)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1047)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1047)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1047)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(191102976)
	Receiver's instance variables: 
		timeStamp: 	260796
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-175@123)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1047)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1047)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1047)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1047)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(191102976)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(-141@182) corner: (-125@198)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(-141@182) corner: (-125@198)
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(191102976)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(-141@182) mouseOver nil nil]
		targetOffset: 	(73@432)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 260178 -141 182 0 0 0 1)
		lastKeyScanCode: 	34
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
[ :i | 
i to
	ifNotNil: [ 
		| targetNS |
		targetNS := i to first belongsTo belongsTo.
		targetNS = varUtil
			ifTrue: [ self halt ] ] ] in [ :c | 
| found |
found := false.
c outgoingInvocations
	do: [ :i | 
		i to
			ifNotNil: [ 
				| targetNS |
				targetNS := i to first belongsTo belongsTo.
				targetNS = varUtil
					ifTrue: [ self halt ] ] ].
found
	ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
[ :c | 
| found |
found := false.
c outgoingInvocations
	do: [ :i | 
		i to
			ifNotNil: [ 
				| targetNS |
				targetNS := i to first belongsTo belongsTo.
				targetNS = varUtil
					ifTrue: [ self halt ] ] ].
found
	ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
20 February 2014 5:25:42.14127 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ found := true ] ] ].
			self halt.
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	false
		c: 	DailyMenuplan in com::ese2013::mub::model (Class)
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::ese2013...etc...
	Arguments and temporary variables: 
		aBlock: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		d...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::e...etc...
		firstIndex: 	1
		lastIndex: 	7


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'result := ''''.   
varUtil := MooseModel root first allNamespa...etc...
		itsSelection: 	a Text for 'result := ''''.   
varUtil := MooseModel root first a...etc...
		itsSelectionString: 	'result := ''''.   
varUtil := MooseModel root first allNam...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		dete...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1226)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1226)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1226)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1226)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	11
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(843841536)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(191102976)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(191102976)
	Receiver's instance variables: 
		timeStamp: 	343774
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-119@142)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(191102976)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(-85@201) corner: (-69@217)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(191102976)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(-85@201) mouseOver nil nil]
		targetOffset: 	(40@472)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 343137 -85 201 0 0 0 1)
		lastKeyScanCode: 	34
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1448@1166)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(800587776) an Imag...etc...
		fullBounds: 	(0@0) corner: (1448@1166)
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ found := true ] ] ].
			self halt.
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
20 February 2014 5:26:16.168873 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ 
									found := true.
									self halt ] ] ].
			self halt.
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	false
		c: 	DailyMenuplan in com::ese2013::mub::model (Class)
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::ese2013...etc...
	Arguments and temporary variables: 
		aBlock: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		d...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::e...etc...
		firstIndex: 	1
		lastIndex: 	7


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'
result := ''''.   
varUtil := MooseModel root first allNamesp...etc...
		itsSelection: 	a Text for '
result := ''''.   
varUtil := MooseModel root first ...etc...
		itsSelectionString: 	'
result := ''''.   
varUtil := MooseModel root first allNa...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		dete...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(281 to: 1238)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(281 to: 1238)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(281 to: 1238)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(281 to: 1238)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	11
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(843841536)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(191102976)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(191102976)
	Receiver's instance variables: 
		timeStamp: 	377798
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-127@128)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1085)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1085)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(191102976)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(-93@187) corner: (-77@203)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(191102976)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(-93@187) mouseOver nil nil]
		targetOffset: 	(103@469)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 376809 -93 187 0 0 0 1)
		lastKeyScanCode: 	34
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1448@1166)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(800587776) an Imag...etc...
		fullBounds: 	(0@0) corner: (1448@1166)
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ 
									found := true.
									self halt ] ] ].
			self halt.
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
20 February 2014 5:26:33.244872 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

[ :i | 
i to
	ifNotNil: [ 
		| targetNS |
		targetNS := i to first belongsTo belongsTo.
		targetNS = varUtil
			ifTrue: [ 
				found := true.
				self halt ] ] ] in DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ 
									found := true.
									self halt ] ] ].
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		c: 	Model in com::ese2013::mub::model (Class)
		i: 	saveFavorites -> dataSource#storeFavorites(mensas) (Invocation)
		found: 	true
		targetNS: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(init -> #ModelCreationTask(menuManager,dataSource,this) (Invocation) ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :i | 
i to
	ifNotNil: [ 
		| targetNS |
		targetNS := i to first belo...etc...
		index: 	35
	Receiver's instance variables: 
		array: 	an Array(init -> #ModelCreationTask(menuManager,dataSource,this) (Invoca...etc...
		firstIndex: 	1
		lastIndex: 	37


DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ 
									found := true.
									self halt ] ] ].
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	true
		c: 	Model in com::ese2013::mub::model (Class)
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::ese2013...etc...
	Arguments and temporary variables: 
		aBlock: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		d...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::e...etc...
		firstIndex: 	1
		lastIndex: 	7


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'result := ''''.   
varUtil := MooseModel root first allNamespa...etc...
		itsSelection: 	a Text for 'result := ''''.   
varUtil := MooseModel root first a...etc...
		itsSelectionString: 	'result := ''''.   
varUtil := MooseModel root first allNam...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		dete...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1225)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1225)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1225)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1225)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	11
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(843841536)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(191102976)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(191102976)
	Receiver's instance variables: 
		timeStamp: 	394875
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-188@136)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(191102976)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(-154@195) corner: (-138@211)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(-154@195) corner: (-138@211)
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(191102976)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(-154@195) mouseOver nil nil]
		targetOffset: 	(75@449)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 394333 -154 194 0 0 0 1)
		lastKeyScanCode: 	34
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
[ :i | 
i to
	ifNotNil: [ 
		| targetNS |
		targetNS := i to first belongsTo belongsTo.
		targetNS = varUtil
			ifTrue: [ 
				found := true.
				self halt ] ] ] in DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ 
									found := true.
									self halt ] ] ].
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ 
									found := true.
									self halt ] ] ].
			found
				ifFalse: [ result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
20 February 2014 5:27:09.137482 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ 
									found := true.
									self halt ] ] ].
			found
				ifFalse: [ 
					self halt.
					result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	false
		c: 	DailyMenuplan in com::ese2013::mub::model (Class)
	Receiver's instance variables: 
nil

OrderedCollection>>do:
	Receiver: an OrderedCollection(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::ese2013...etc...
	Arguments and temporary variables: 
		aBlock: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		d...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(DailyMenuplan in com::ese2013::mub::model (Class) Day in com::e...etc...
		firstIndex: 	1
		lastIndex: 	7


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'result := ''''.   
varUtil := MooseModel root first allNamespa...etc...
		itsSelection: 	a Text for 'result := ''''.   
varUtil := MooseModel root first a...etc...
		itsSelectionString: 	'result := ''''.   
varUtil := MooseModel root first allNam...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		dete...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(191102976)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1236)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1236)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1236)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(843841536)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(31.0@59.0) corner: (1417.0@1107.0)
		owner: 	a SystemWindow(800587776)
		submorphs: 	an Array(a ScrollBar(883687424) a TransformMorph(46923776))
		fullBounds: 	(31@59) corner: (1417@1107)
		color: 	NewColor white
		extension: 	a MorphExtension (169869312) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(883687424)
		scroller: 	a TransformMorph(46923776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(127401984)
		textMorph: 	a TextMorphForEditView(191102976)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(282 to: 1236)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(843841536)
		secondArg: 	a PluggableTextMorph(843841536)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	11
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(843841536)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(843841536)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(843841536)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(843841536)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(191102976)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(191102976)
	Receiver's instance variables: 
		timeStamp: 	430768
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-112@158)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(191102976)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1367@1066)
		owner: 	a TransformMorph(46923776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1367@1066)
		color: 	NewColor black
		extension: 	a MorphExtension (227803136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result  varUtil varService varModel v...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	NewColor black
		editView: 	a PluggableTextMorph(843841536)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(191102976)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(-78@217) corner: (-62@233)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(-78@217) corner: (-62@233)
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(191102976)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(-78@217) mouseOver CMD nil nil]
		targetOffset: 	(39@451)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 429825 -78 217 0 8 0 1)
		lastKeyScanCode: 	34
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1448@1166)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(800587776) an Imag...etc...
		fullBounds: 	(0@0) corner: (1448@1166)
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
DoIt
	result := ''.
	varUtil := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varService := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.service'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varModel := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.model'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	varSocial := MooseModel root first allNamespaces
		detect: [ :n | {'com.ese2013.mub.social'} includes: (n mooseName copyReplaceAll: '::' with: '.') ].
	^ varModel allClasses
		do: [ :c | 
			| found |
			found := false.
			c outgoingInvocations
				do: [ :i | 
					i to
						ifNotNil: [ 
							| targetNS |
							targetNS := i to first belongsTo belongsTo.
							targetNS = varUtil
								ifTrue: [ 
									found := true.
									self halt ] ] ].
			found
				ifFalse: [ 
					self halt.
					result := result , 'fail: Model must DependOn(Util)' , String lf ] ] in UndefinedObject>>DoIt
OrderedCollection>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392980100/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 11:55:01.748595 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392981847/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 12:24:08.828918 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392981885/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 12:24:47.468018 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392981938/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 12:25:39.901836 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392981953/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 12:25:54.763947 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392982014/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 12:26:55.873362 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392982040/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 12:27:22.461031 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392982049/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 12:27:30.533402 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1392982103/DIMooseDependencies.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
21 February 2014 12:28:24.69844 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyR...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (0 entities)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.ese2013.mub.util.database'} includes: (n mooseName copyRep...etc...
	Receiver's instance variables: 
		mooseID: 	17
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/newA...etc...
		mooseModel: 	a MooseModel #noname(1)
		out: 	nil
		varUtil: 	nil
		varService: 	nil
		varModel: 	nil
		varSocial: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varService varModel varSocial...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varService varModel varSocial fo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varService varModel varSocia...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varServi...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varService ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSe...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
MooseGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE/DICTO/analysis/output/a-1393001463/DIGrepFileContent.st
===============================================================================
SyntaxErrorNotification
21 February 2014 5:51:06.852504 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'End of statement list encounted ->'
		location: 	10
		code: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/GoogleD...etc...
	Receiver's instance variables: 
		contents: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Goo...etc...
		fileReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROT...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/GoogleD...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'End of statement list encounted'
		location: 	10


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/G...etc...
		doitFlag: 	false
		errorString: 	'End of statement list encounted'
		location: 	10
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'End of statement list encounted'
		errorNode: 	nil
		errorMessage: 	'End of statement list encounted'
		errorPosition: 	10
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBLiteralToken('\<<dependency>(.*)</dependency>\>')
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Googl...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode()
		statements: 	an OrderedCollection(RBMessageNode(grep - rl))
		return: 	true
		periods: 	an OrderedCollection()
		returnPosition: 	nil
		node: 	RBMessageNode(grep - rl)
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBLiteralToken('\<<dependency>(.*)</dependency>\>')
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Googl...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode()
		temps: 	#()
		leftBar: 	nil
		rightBar: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBLiteralToken('\<<dependency>(.*)</dependency>\>')
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Googl...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatements:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBLiteralToken('\<<dependency>(.*)</dependency>\>')
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Googl...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Goog...etc...
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBLiteralToken('\<<dependency>(.*)</dependency>\>')
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Googl...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Goog...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Goog...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(grep -rl '\<<dependency>(.*)</dependency>\>' /Users/caracciolo/GoogleDri...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'grep -rl ''\<<dependency>(.*)</dependency>\>'' /Users/caracciolo/Goo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(grep -rl '\<<dependency>(.*)</dependency>\>' /Us...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(grep -rl '\<<dependenc...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(grep -rl '\<<dependency>(.*)</dependency>\>' /Users...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(grep -rl '\<<dependency>(.*)</dependency>\>' ...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(grep -rl '\<<dependenc...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/newADL/_PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser(RBParser)>>parseStatements:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393841699/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:15:07.694909 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9788
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9772)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393841825/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:17:12.938753 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varExampleClass2: 	nil
		varService: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varExa...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842632/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:32:18.436872 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespace)::m...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespace)::m...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespace)::m...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespace)::m...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespace)::m...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) com (Namespace)::ese2013 (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9786
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(<Default Package> (Namespace) com (Namespac...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9770)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842632/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:32:30.495108 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:34:48.477965 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace) java (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:35:22.496793 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Namespace):...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Names...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Namespace):...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Names...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Namespace):...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Names...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Namespace):...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Names...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Namespace):...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) com (Namespace)::ese2013 (Namespace) com (Names...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9784
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace) com (Namespace)::ese2013 (N...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9768)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:36:28.48729 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:42:19.350464 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (Namespa...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (N...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (Namespa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (N...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (Namespa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (N...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (Namespa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (N...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (Namespa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::model (N...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:42:49.389199 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default Packag...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default ...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default Packag...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default Packag...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default Packag...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default Packag...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) <Default ...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9784
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9768)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393843364/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:42:55.460208 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::service ...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9788
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9772)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 11:45:43.806064 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9788
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9772)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:19:50.402679 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9786
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9770)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:20:10.382343 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::text (Namespace) com (Namespace)::ese2013 (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9784
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::text (Namespace) com (Nam...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9768)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:20:28.244257 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393845623/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:20:34.309182 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:21:28.785876 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) java (Namespace) com (Namespace)::es...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) java (Namespace) com (Namespac...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) java (Namespace) com (Namespace)::es...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) java (Namespace) com (Namespac...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) java (Namespace) com (Namespace)::es...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) java (Namespace) com (Namespac...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) java (Namespace) com (Namespace)::es...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) java (Namespace) com (Namespac...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) java (Namespace) com (Namespace)::es...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) java (Namespace) com (Namespac...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9784
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::io (Namespace) java (Name...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9768)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393845683/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:21:34.833712 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9784
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::util (Namespace)::concurr...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9768)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varExampleClass2: 	nil
		varService: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varExa...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:22:10.63997 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespace) co...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespace) co...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespace) co...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespace) co...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespace) co...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) <Default Package> (Namespa...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9788
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace) <Defau...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9772)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:24:27.897167 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9784
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::util (Namespace)::concurr...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9768)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:25:33.731608 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace) com (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393845928/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 12:25:39.832919 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace) java (Namespace) java (Namespace)::util (Namespace) j...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) java (Namespace) java (Namespace)::util (Namesp...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace) java (Namespace) java (Namespace)::util (Namespace) j...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) java (Namespace) java (Namespace)::util (Namesp...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace) java (Namespace) java (Namespace)::util (Namespace) j...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) java (Namespace) java (Namespace)::util (Namesp...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace) java (Namespace) java (Namespace)::util (Namespace) j...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) java (Namespace) java (Namespace)::util (Namesp...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace) java (Namespace) java (Namespace)::util (Namespace) j...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace) java (Namespace) java (Namespace)::util (Namesp...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace) java (Namespace) java (Name...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varExampleClass2: 	nil
		varService: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varExa...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 1:08:14.606393 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 1:08:36.518855 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9788
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9772)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 1:39:07.729587 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 5:10:43.517802 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::text (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace) java (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 5:10:49.832383 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Namespace)...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::io (Namespace) com (Namespace)::ese2013 (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::io (Namespace) com (Names...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 5:10:55.34027 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace) java (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace) java (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 5:11:02.767459 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 5:11:08.055573 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 6:22:23.642333 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 6:22:29.784674 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9786
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9770)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 6:22:35.158522 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace) com (Names...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace) com ...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9784
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::util (Namespace)::concurr...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9768)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 6:22:41.627714 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(<Default Package> (Namespace) java (Namespace)::lang (Namespace) java...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) java (Namespace)::lang (Namespace...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(<Default Package> (Namespace) java (Namespace)::lang (Namespace) java...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) java (Namespace)::lang (Namespace...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(<Default Package> (Namespace) java (Namespace)::lang (Namespace) java...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) java (Namespace)::lang (Namespace...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(<Default Package> (Namespace) java (Namespace)::lang (Namespace) java...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) java (Namespace)::lang (Namespace...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(<Default Package> (Namespace) java (Namespace)::lang (Namespace) java...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(<Default Package> (Namespace) java (Namespace)::lang (Namespace...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9784
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(<Default Package> (Namespace) java (Namespa...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9768)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
3 March 2014 6:22:46.811585 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9788
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9772)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
4 March 2014 3:24:27.941904 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace)::concurrent (Namespace)::atomic (N...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace)::concurrent (Namespace)::ato...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9788
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::util (Namespace)::concurr...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9772)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
6 March 2014 2:38:42.011442 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9786
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::util (Namespace) java (Na...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9770)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
6 March 2014 2:39:07.147013 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(java (Namespace)::util (Namespace) java (Namespace)::lang (Namespace)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(java (Namespace)::util (Namespace) java (Namespace)::lang (Name...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9786
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(java (Namespace)::util (Namespace) java (Na...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9770)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
6 March 2014 2:39:55.965872 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9786
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9770)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
6 March 2014 2:40:40.304464 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
6 March 2014 2:41:28.720369 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Na...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
6 March 2014 2:41:50.357694 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9787
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9771)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/analysis/a-1393842882/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
6 March 2014 2:43:34.694732 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll:...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Namespace...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		array: 	an Array(com (Namespace)::ese2013 (Namespace)::mub (Namespace)::map (Nam...etc...
		firstIndex: 	1
		lastIndex: 	23


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (23 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | {'com.test.oldclassic'} includes: (n mooseName copyReplaceAll: '...etc...
	Receiver's instance variables: 
		mooseID: 	9785
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(com (Namespace)::ese2013 (Namespace)::mub (...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dict...etc...
		mooseModel: 	a MooseModel #noname(9769)
		out: 	nil
		varUtil: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::util (Namespace...etc...
		varSocial: 	com (Namespace)::ese2013 (Namespace)::mub (Namespace)::social (Names...etc...
		varExampleClass: 	nil
		varService: 	nil
		varExampleClass2: 	nil
		varModel: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varSocial varExampleClass var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varSocial varExampleClass varSer...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varSocial varExampleClass va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varSocia...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varSocial v...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varSo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROT...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/_PROTOTYPE/DICTO/d...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPES/current/DICTO/analysis/a-1394617514/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
An attempt to use interactive tools detected, while in non-interactive mode
	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPES/current/DICTO/tools/moose/model.mse'
12 March 2014 10:45:19.043821 am

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

NonInteractiveUIManager>>nonInteractive:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		anException: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Pr...etc...
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		anException: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Pr...etc...
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


FileDoesNotExistException>>defaultAction
	Receiver: FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPE...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPES/curr...etc...
		readOnly: 	true


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Proj...etc...
	Receiver's instance variables: 
nil

MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Proj...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Proj...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ aCommandLinehandler activateWith: commandLine ]


FileDoesNotExistException(Exception)>>pass
	Receiver: FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPE...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPES/curr...etc...
		readOnly: 	true


STCommandLineHandler>>handleError:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		error: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Projects...etc...
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTY...etc...
		fileReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROT...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :e | self handleError: e reference: aReference ] in STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTY...etc...
		e: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dic...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>cull:
	Receiver: [ :e | self handleError: e reference: aReference ]
	Arguments and temporary variables: 
		anArg: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Projects...etc...
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>handleErrorsDuring:reference:
		startpc: 	48
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Proj...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	STCommandLineHandler>>handleErrorsDuring:reference:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ codeImporter evaluate ]


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Proj...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	STCommandLineHandler>>handleErrorsDuring:reference:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ codeImporter evaluate ]


FileDoesNotExistException(Exception)>>signal
	Receiver: FileDoesNotExistException: '/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPE...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPES/curr...etc...
		readOnly: 	true


MultiByteFileStream class(StandardFileStream class)>>readOnlyFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPES/curr...etc...
		fullName: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPES/curr...etc...
		f: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>readOnlyFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'model.mse'
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: #stderr #Stdin->nil #Stdi...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	nil
		stream: 	nil
		mooseModel: 	a MooseModel #noname(0)
		out: 	nil
		varWithDeadlock: 	nil
		varWithoutDeadlock: 	nil
		varContrib: 	nil
		varUtil: 	nil
		varTest: 	nil
		varApplication: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varWithDeadlock varWithoutDeadlock va...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varWithDeadlock varWithoutDeadlock varCo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varWithDeadlock varWithoutDeadlock v...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varWithDeadlock ...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varWithDeadlock var...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varWithDeadlo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/GoogleDrive/_WORK/Projects/...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTY...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTY...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYP...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PRO...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/GoogleDrive/_WORK/Pr...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/GoogleDrive/_WORK/Projects/Dicto/__PROTOTYPES/curre...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver



--- The full stack ---
NonInteractiveUIManager>>nonInteractive:
NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
FileDoesNotExistException>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
FileDoesNotExistException(Exception)>>pass
STCommandLineHandler>>handleError:reference:
[ :e | self handleError: e reference: aReference ] in STCommandLineHandler>>handleErrorsDuring:reference:
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
FileDoesNotExistException(Exception)>>signal
MultiByteFileStream class(StandardFileStream class)>>readOnlyFileNamed:
FileStream class>>readOnlyFileNamed:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
ErrorNonInteractive>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
ErrorNonInteractive(Exception)>>signal
ErrorNonInteractive class>>signalForException:
NonInteractiveUIManager>>nonInteractive:
NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
FileDoesNotExistException>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/bin/analysis/a-1399556971/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
8 May 2014 3:49:37.997014 pm

VM: Mac OS - intel - 1092 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>ensureBoundsFrom:to:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>at:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(SequenceableCollection)>>first
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseModel(MooseAbstractGroup)>>first
	Receiver: a MooseModel #Root(0)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		mooseID: 	2
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()
		sourceLanguage: 	nil
		name: 	'Root'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PROTOT...etc...
		mooseModel: 	a MooseModel #noname(0)
		out: 	nil
		varWithDeadlock: 	nil
		varWithoutDeadlock: 	nil
		varContrib: 	nil
		varUtil: 	nil
		varTest: 	nil
		varApplication: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varWithDeadlock varWithoutDeadlock va...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varWithDeadlock varWithoutDeadlock varCo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varWithDeadlock varWithoutDeadlock v...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varWithDeadlock ...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PR...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varWithDeadlock var...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varWithDeadlo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PR...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/b...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/cur...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/bin/dict...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>ensureBoundsFrom:to:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
MooseModel(MooseAbstractGroup)>>first
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/bin/analysis/a-1399556971/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
8 May 2014 3:50:25.644863 pm

VM: Mac OS - intel - 1092 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>ensureBoundsFrom:to:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>at:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(SequenceableCollection)>>first
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseModel(MooseAbstractGroup)>>first
	Receiver: a MooseModel #Root(0)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		mooseID: 	2
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()
		sourceLanguage: 	nil
		name: 	'Root'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PROTOT...etc...
		mooseModel: 	a MooseModel #noname(0)
		out: 	nil
		varWithDeadlock: 	nil
		varWithoutDeadlock: 	nil
		varContrib: 	nil
		varUtil: 	nil
		varTest: 	nil
		varApplication: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varWithDeadlock varWithoutDeadlock va...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varWithDeadlock varWithoutDeadlock varCo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varWithDeadlock varWithoutDeadlock v...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varWithDeadlock ...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PR...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varWithDeadlock var...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varWithDeadlo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PR...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/b...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/cur...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/bin/dict...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>ensureBoundsFrom:to:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
MooseModel(MooseAbstractGroup)>>first
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/bin/analysis/a-1399557385/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
8 May 2014 3:56:45.069126 pm

VM: Mac OS - intel - 1092 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>ensureBoundsFrom:to:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		fromIndex: 	1
		toIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>at:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(SequenceableCollection)>>first
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	0


MooseModel(MooseAbstractGroup)>>first
	Receiver: a MooseModel #Root(0)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		mooseID: 	2
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()
		sourceLanguage: 	nil
		name: 	'Root'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	nil
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PROTOT...etc...
		mooseModel: 	a MooseModel #noname(0)
		out: 	nil
		varWithDeadlock: 	nil
		varWithoutDeadlock: 	nil
		varContrib: 	nil
		varUtil: 	nil
		varTest: 	nil
		varApplication: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varWithDeadlock varWithoutDeadlock va...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varWithDeadlock varWithoutDeadlock varCo...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varWithDeadlock varWithoutDeadlock v...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varWithDeadlock ...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PR...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varWithDeadlock var...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varWithDeadlo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PR...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/b...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/cur...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/bin/dict...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>ensureBoundsFrom:to:
OrderedCollection>>at:
OrderedCollection(SequenceableCollection)>>first
MooseModel(MooseAbstractGroup)>>first
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/bin/analysis/DictoTestSuite/1405345253/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "nextPutAll:" is nil
14 July 2014 3:41:06.259468 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

UndefinedObject(Object)>>doesNotUnderstand: #nextPutAll:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	nextPutAll: 'fail: ~Application cannot DependOn(Util)
fail: ~Applicat...etc...
		exception: 	MessageNotUnderstood: receiver of "nextPutAll:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	true
		result: 	'fail: ~Application cannot DependOn(Util)
fail: ~Application cannot Dep...etc...
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PROTOT...etc...
		mooseModel: 	a MooseModel #noname(52656)
		out: 	nil
		varUtil: 	org (Namespace)::jhotdraw (Namespace)::util (Namespace)
		varContrib: 	org (Namespace)::jhotdraw (Namespace)::contrib (Namespace)
		varApplication: 	org (Namespace)::jhotdraw (Namespace)::application (Namespace)
		varTest: 	org (Namespace)::jhotdraw (Namespace)::test (Namespace)
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varContrib varApplication var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PR...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/__PR...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/b...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/cur...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/__PROTOTYPE/current/bin/dict...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #nextPutAll:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1406638682/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
29 July 2014 2:58:27.485526 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (Namesp...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
	Receiver's instance variables: 
		array: 	an Array(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (...etc...
		firstIndex: 	1
		lastIndex: 	64


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
	Receiver's instance variables: 
		array: 	an Array(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (...etc...
		firstIndex: 	1
		lastIndex: 	64


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (...etc...
		firstIndex: 	1
		lastIndex: 	64


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (...etc...
		firstIndex: 	1
		lastIndex: 	64


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (Namesp...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
	Receiver's instance variables: 
		array: 	an Array(javax (Namespace) org (Namespace)::jhotdraw (Namespace)::test (...etc...
		firstIndex: 	1
		lastIndex: 	64


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (64 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
	Receiver's instance variables: 
		mooseID: 	52672
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(javax (Namespace) org (Namespace)::jhotdraw...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	true
		result: 	'fail: ~Application cannot DependOn(Util)
fail: ~Application cannot Dep...etc...
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		mooseModel: 	a MooseModel #noname(52656)
		out: 	nil
		varUtil: 	org (Namespace)::jhotdraw (Namespace)::util (Namespace)
		varContrib: 	org (Namespace)::jhotdraw (Namespace)::contrib (Namespace)
		varApplication: 	org (Namespace)::jhotdraw (Namespace)::application (Namespace)
		varTest: 	org (Namespace)::jhotdraw (Namespace)::test (Namespace)
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varContrib varApplication var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/../...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1406638722/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
NotFound: [ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ] not found in OrderedCollection
29 July 2014 2:59:08.477821 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contrib (Nam...etc...
	Arguments and temporary variables: 
		anObject: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
	Receiver's instance variables: 
		array: 	an Array(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contri...etc...
		firstIndex: 	1
		lastIndex: 	64


[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contrib (Nam...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
	Receiver's instance variables: 
		array: 	an Array(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contri...etc...
		firstIndex: 	1
		lastIndex: 	64


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contrib (Nam...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contri...etc...
		firstIndex: 	1
		lastIndex: 	64


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contrib (Nam...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
	Receiver's instance variables: 
		array: 	an Array(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contri...etc...
		firstIndex: 	1
		lastIndex: 	64


OrderedCollection(Collection)>>detect:
	Receiver: an OrderedCollection(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contrib (Nam...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
	Receiver's instance variables: 
		array: 	an Array(org (Namespace)::jhotdraw (Namespace)::test (Namespace)::contri...etc...
		firstIndex: 	1
		lastIndex: 	64


FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
	Receiver: All famixnamespaces (64 FAMIXNamespaces)
	Arguments and temporary variables: 
		aBlock: 	[ :n | packageName = (n mooseName copyReplaceAll: '::' with: '.') ]
	Receiver's instance variables: 
		mooseID: 	52672
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage(org (Namespace)::jhotdraw (Namespace)::test...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		found: 	true
		result: 	'fail: ~Application cannot DependOn(Util)
fail: ~Application cannot Dep...etc...
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		mooseModel: 	a MooseModel #noname(52656)
		out: 	nil
		varUtil: 	org (Namespace)::jhotdraw (Namespace)::util (Namespace)
		varContrib: 	org (Namespace)::jhotdraw (Namespace)::contrib (Namespace)
		varApplication: 	org (Namespace)::jhotdraw (Namespace)::application (Namespace)
		varTest: 	org (Namespace)::jhotdraw (Namespace)::test (Namespace)
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result varUtil varContrib varApplication var...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/../...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in OrderedCollection(Collection)>>detect:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
FAMIXNamespaceGroup(MooseAbstractGroup)>>detect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1406639003/DIMooseDependencies-test.st
===============================================================================
SyntaxErrorNotification
29 July 2014 3:03:40.515004 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'Unknown input at end ->'
		location: 	1899
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...
		fileReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/anal...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'Unknown input at end'
		location: 	1899


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varContrib varApplication ...etc...
		doitFlag: 	false
		errorString: 	'Unknown input at end'
		location: 	1899
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'Unknown input at end'
		errorNode: 	nil
		errorMessage: 	'Unknown input at end'
		errorPosition: 	1899
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($])
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		node: 	RBSequenceNode(| stream mooseModel out result varUtil varContrib varAppli...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($])
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1406639049/DIMooseDependencies-test.st
===============================================================================
SyntaxErrorNotification
29 July 2014 3:04:17.680656 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'Unknown input at end ->'
		location: 	1899
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...
		fileReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/anal...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'Unknown input at end'
		location: 	1899


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varContrib varApplication ...etc...
		doitFlag: 	false
		errorString: 	'Unknown input at end'
		location: 	1899
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'Unknown input at end'
		errorNode: 	nil
		errorMessage: 	'Unknown input at end'
		errorPosition: 	1899
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($])
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		node: 	RBSequenceNode(| stream mooseModel out result varUtil varContrib varAppli...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($])
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1406639059/DIMooseDependencies-test.st
===============================================================================
SyntaxErrorNotification
29 July 2014 3:04:30.076005 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'Unknown input at end ->'
		location: 	1899
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...
		fileReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/anal...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'Unknown input at end'
		location: 	1899


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varContrib varApplication ...etc...
		doitFlag: 	false
		errorString: 	'Unknown input at end'
		location: 	1899
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'Unknown input at end'
		errorNode: 	nil
		errorMessage: 	'Unknown input at end'
		errorPosition: 	1899
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($])
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		node: 	RBSequenceNode(| stream mooseModel out result varUtil varContrib varAppli...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($])
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1406639085/DIMooseDependencies-test.st
===============================================================================
SyntaxErrorNotification
29 July 2014 3:05:03.185078 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	'Unknown input at end ->'
		location: 	1899
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...
		fileReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/anal...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	'Unknown input at end'
		location: 	1899


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varContrib varApplication ...etc...
		doitFlag: 	false
		errorString: 	'Unknown input at end'
		location: 	1899
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'Unknown input at end'
		errorNode: 	nil
		errorMessage: 	'Unknown input at end'
		errorPosition: 	1899
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($])
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		node: 	RBSequenceNode(| stream mooseModel out result varUtil varContrib varAppli...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($])
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1406640335/DIMooseDependencies-test.st
===============================================================================
SyntaxErrorNotification
29 July 2014 3:25:52.823355 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	''')'' expected ->'
		location: 	1689
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...
		fileReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/anal...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	''')'' expected'
		location: 	1689


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varContrib varApplication ...etc...
		doitFlag: 	false
		errorString: 	''')'' expected'
		location: 	1689
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	''')'' expected'
		errorNode: 	nil
		errorMessage: 	''')'' expected'
		errorPosition: 	1689
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseParenthesizedExpression
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		leftParen: 	1611
		node: 	RBMessageNode(hasDependency value: 'org.jhotdraw.application' value: 'org...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseUnaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseBinaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseKeywordMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseCascadeMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		receiver: 	nil
		messages: 	nil
		semicolons: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseAssignment
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		position: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varContrib ...etc...
		statements: 	an OrderedCollection(RBAssignmentNode(mooseModel := MooseModel new)...etc...
		return: 	false
		periods: 	an OrderedCollection(130 212 252 304 320 853 1010 1155 1313 1453 1592 ...etc...
		returnPosition: 	nil
		node: 	RBAssignmentNode(found := false)
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varContrib...etc...
		temps: 	an OrderedCollection(RBTemporaryNode(stream) RBTemporaryNode(mooseModel)...etc...
		leftBar: 	1
		rightBar: 	99
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatements:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseParenthesizedExpression
RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
RBExplicitVariableParser(RBParser)>>parseUnaryMessage
RBExplicitVariableParser(RBParser)>>parseBinaryMessage
RBExplicitVariableParser(RBParser)>>parseKeywordMessage
RBExplicitVariableParser(RBParser)>>parseCascadeMessage
RBExplicitVariableParser(RBParser)>>parseAssignment
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser(RBParser)>>parseStatements:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1406640367/DIMooseDependencies-test.st
===============================================================================
SyntaxErrorNotification
29 July 2014 3:26:25.812676 pm

VM: Mac OS - intel - 1093 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

FileCompilerRequestor>>notify:at:in:
	Receiver: a FileCompilerRequestor
	Arguments and temporary variables: 
		message: 	''')'' expected ->'
		location: 	1689
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...
		fileReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/anal...etc...
		interactive: 	false


[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
		exception: 	SyntaxErrorNotification
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>cull:
	Receiver: [ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext ...etc...
	Arguments and temporary variables: 
		anArg: 	SyntaxErrorNotification
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	109
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		value: 	nil
	Receiver's instance variables: 
		sender: 	OpalCompiler>>compile
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: se...etc...


SyntaxErrorNotification(Exception)>>signal
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a RBExplicitVariableParser
		signalContext: 	SyntaxErrorNotification(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		inClass: 	Object
		code: 	'| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
		category: 	nil
		doitFlag: 	false
		errorMessage: 	''')'' expected'
		location: 	1689


SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
	Receiver: SyntaxErrorNotification
	Arguments and temporary variables: 
		aClass: 	Object
		aCategory: 	nil
		codeString: 	'| stream mooseModel out result  varUtil varContrib varApplication ...etc...
		doitFlag: 	false
		errorString: 	''')'' expected'
		location: 	1689
	Receiver's instance variables: 
		superclass: 	Error
		methodDict: 	a MethodDictionary(#category->SyntaxErrorNotification>>#category #d...etc...
		format: 	154
		layout: 	a FixedLayout
		instanceVariables: 	#('inClass' 'code' 'category' 'doitFlag' 'errorMessage' 'loc...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SyntaxErrorNotification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-Exception'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser(RBParser)>>parserError:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	''')'' expected'
		errorNode: 	nil
		errorMessage: 	''')'' expected'
		errorPosition: 	1689
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseParenthesizedExpression
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		leftParen: 	1611
		node: 	RBMessageNode(hasDependency value: 'org.jhotdraw.application' value: 'org...etc...
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseUnaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseBinaryMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseKeywordMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseCascadeMessage
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		receiver: 	nil
		messages: 	nil
		semicolons: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseAssignment
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		node: 	nil
		position: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatementList:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varContrib ...etc...
		statements: 	an OrderedCollection(RBAssignmentNode(mooseModel := MooseModel new)...etc...
		return: 	false
		periods: 	an OrderedCollection(130 212 252 304 320 853 1010 1155 1313 1453 1592 ...etc...
		returnPosition: 	nil
		node: 	RBAssignmentNode(found := false)
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatements:into:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode(| stream mooseModel out result varUtil varContrib...etc...
		temps: 	an OrderedCollection(RBTemporaryNode(stream) RBTemporaryNode(mooseModel)...etc...
		leftBar: 	1
		rightBar: 	99
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseStatements:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser(RBParser)>>parseExpression:
	Receiver: a RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBSpecialCharacterToken($.)
		nextToken: 	nil
		errorBlock: 	nil
		source: 	'| stream mooseModel out result  varUtil varContrib varApplication varT...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil
		currentVariableNodeClass: 	nil
		currentScope: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
		aBlock: 	nil
		node: 	nil
		parser: 	a RBExplicitVariableParser
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


RBExplicitVariableParser class(RBParser class)>>parseExpression:
	Receiver: RBExplicitVariableParser
	Arguments and temporary variables: 
		aString: 	'| stream mooseModel out result  varUtil varContrib varApplication var...etc...
	Receiver's instance variables: 
		superclass: 	RBParser
		methodDict: 	a MethodDictionary(#argumentNodeClass->RBExplicitVariableParser>>#a...etc...
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#('currentVariableNodeClass' 'currentScope')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RBExplicitVariableParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'
		traitComposition: 	{}
		localSelectors: 	nil


OpalCompiler>>parseExpression
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parseClass: 	RBExplicitVariableParser
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		method: 	nil
		expression: 	nil
		selector: 	nil
		arguments: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result  varUtil varContrib varApplication varTes...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result  varUtil varContrib varApplication va...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result  varUtil varContr...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result  varUtil varContrib ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result  varUtil varCo...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...



--- The full stack ---
FileCompilerRequestor>>notify:at:in:
[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
		self compilationContext requestor notify: exception errorMessage , ' ->' at: exception location in: exception errorCode.
		^ self compilationContext failBlock value ]
	ifNil: [ exception pass ] ] in OpalCompiler>>compile
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
SyntaxErrorNotification(Exception)>>signal
SyntaxErrorNotification class>>inClass:category:withCode:doitFlag:errorMessage:location:
RBExplicitVariableParser(RBParser)>>parserError:
RBExplicitVariableParser(RBParser)>>parseParenthesizedExpression
RBExplicitVariableParser(RBParser)>>parsePrimitiveObject
RBExplicitVariableParser(RBParser)>>parseUnaryMessage
RBExplicitVariableParser(RBParser)>>parseBinaryMessage
RBExplicitVariableParser(RBParser)>>parseKeywordMessage
RBExplicitVariableParser(RBParser)>>parseCascadeMessage
RBExplicitVariableParser(RBParser)>>parseAssignment
RBExplicitVariableParser(RBParser)>>parseStatementList:into:
RBExplicitVariableParser(RBParser)>>parseStatements:into:
RBExplicitVariableParser(RBParser)>>parseStatements:
RBExplicitVariableParser(RBParser)>>parseExpression:
RBExplicitVariableParser class(RBParser class)>>parseExpression:onError:
RBExplicitVariableParser class(RBParser class)>>parseExpression:
OpalCompiler>>parseExpression
OpalCompiler>>parse
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1412256848/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 3:34:25.751198 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	336
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result hasDependency| 
mooseModel := MooseModel ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result hasDependency| 
mooseModel := MooseMo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result hasDependency| 
m...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result hasDependency| 
moos...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result hasDependency|...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1412257830/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 3:50:48.333652 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	336
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result hasDependency| 
mooseModel := MooseModel ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result hasDependency| 
mooseModel := MooseMo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result hasDependency| 
m...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result hasDependency| 
moos...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result hasDependency|...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1412257947/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 3:52:45.528073 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	336
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result hasDependency| 
mooseModel := MooseModel ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result hasDependency| 
mooseModel := MooseMo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result hasDependency| 
m...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result hasDependency| 
moos...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result hasDependency|...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1412258434/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:01:56.16706 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	336
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result hasDependency| 
mooseModel := MooseModel ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result hasDependency| 
mooseModel := MooseMo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result hasDependency| 
m...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result hasDependency| 
moos...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result hasDependency|...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:02:39.505206 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	336
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result hasDependency| 
mooseModel := MooseModel ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result hasDependency| 
mooseModel := MooseMo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result hasDependency| 
m...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result hasDependency| 
moos...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result hasDependency|...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:03:06.886418 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	336
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (956.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (956@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21547)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (956.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (956@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21547)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (862@6481)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (862@6481)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (956.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (956@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21547)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (956.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (956@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21547)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:04:29.881736 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	334
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:06:16.336523 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	334
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Cannot compile -- too many literals variables
2 October 2014 4:06:24.710002 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

CompiledMethod class(Object)>>error:
	Receiver: CompiledMethod
	Arguments and temporary variables: 
		aString: 	'Cannot compile -- too many literals variables'
	Receiver's instance variables: 
		superclass: 	ByteArray
		methodDict: 	a MethodDictionary(size 231)
		format: 	3586
		layout: 	a CompiledMethodLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CompiledMethod
		classPool: 	a Dictionary(#LargeFrame->56 #SmallFrame->16 )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'
		traitComposition: 	{}
		localSelectors: 	nil


CompiledMethod class>>newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:
	Receiver: CompiledMethod
	Arguments and temporary variables: 
		numberOfBytes: 	2159
		trailer: 	a CompiledMethodTrailer
		nArgs: 	0
		nTemps: 	5
		stackSize: 	0
		nLits: 	258
		primitiveIndex: 	0
		largeBit: 	nil
		primBits: 	nil
	Receiver's instance variables: 
		superclass: 	ByteArray
		methodDict: 	a MethodDictionary(size 231)
		format: 	3586
		layout: 	a CompiledMethodLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CompiledMethod
		classPool: 	a Dictionary(#LargeFrame->56 #SmallFrame->16 )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'
		traitComposition: 	{}
		localSelectors: 	nil


CompiledMethod class>>primitive:numArgs:numTemps:stackSize:literals:bytecodes:trailer:
	Receiver: CompiledMethod
	Arguments and temporary variables: 
		primNum: 	0
		numArgs: 	0
		numTemps: 	5
		stackSize: 	4
		literals: 	an Array(#MooseModel->MooseModel #MultiByteFileStream->MultiByteFileS...etc...
		bytecodes: 	#[138 1 108 64 204 105 65 66 35 228 229 104 17 16 230 135 17 194 117...etc...
		trailerBytes: 	a CompiledMethodTrailer
		compiledMethod: 	nil
	Receiver's instance variables: 
		superclass: 	ByteArray
		methodDict: 	a MethodDictionary(size 231)
		format: 	3586
		layout: 	a CompiledMethodLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CompiledMethod
		classPool: 	a Dictionary(#LargeFrame->56 #SmallFrame->16 )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'
		traitComposition: 	{}
		localSelectors: 	nil


IRBytecodeGenerator>>compiledMethodWith:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		cm: 	nil
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 323)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 323)
		jumps: 	an IdentityDictionary(size 323)
		literals: 	an Array(#MooseModel->MooseModel #MultiByteFileStream->MultiByteFileS...etc...
		lastLiteral: 	nil
		currentSeqId: 	316
		currentSeqNum: 	323
		bytes: 	an OrderedCollection(76 132 96 254 202)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 323)
		instrMap: 	an OrderedCollection(an IRReturn->1)
		stacks: 	an IdentityDictionary(size 323)
		stack: 	an IRStackCount start 1 stop 0 max 1
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	#(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRTranslator>>compiledMethod
	Receiver: an IRTranslator
	Arguments and temporary variables: 

	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRReturn
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 20061)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 20061)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 20061)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 20061)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(362807296)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(362807296)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	1
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(362807296)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(362807296)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a PluggableTextMorph(362807296)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a PluggableTextMorph(362807296)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(362807296)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil



--- The full stack ---
CompiledMethod class(Object)>>error:
CompiledMethod class>>newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:
CompiledMethod class>>primitive:numArgs:numTemps:stackSize:literals:bytecodes:trailer:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslator>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:06:59.584732 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	334
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:07:12.418891 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	334
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21267)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:08:44.96872 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	334
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Cannot compile -- too many literals variables
2 October 2014 4:09:07.3683 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

CompiledMethod class(Object)>>error:
	Receiver: CompiledMethod
	Arguments and temporary variables: 
		aString: 	'Cannot compile -- too many literals variables'
	Receiver's instance variables: 
		superclass: 	ByteArray
		methodDict: 	a MethodDictionary(size 231)
		format: 	3586
		layout: 	a CompiledMethodLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CompiledMethod
		classPool: 	a Dictionary(#LargeFrame->56 #SmallFrame->16 )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'
		traitComposition: 	{}
		localSelectors: 	nil


CompiledMethod class>>newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:
	Receiver: CompiledMethod
	Arguments and temporary variables: 
		numberOfBytes: 	2147
		trailer: 	a CompiledMethodTrailer
		nArgs: 	0
		nTemps: 	5
		stackSize: 	0
		nLits: 	256
		primitiveIndex: 	0
		largeBit: 	nil
		primBits: 	nil
	Receiver's instance variables: 
		superclass: 	ByteArray
		methodDict: 	a MethodDictionary(size 231)
		format: 	3586
		layout: 	a CompiledMethodLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CompiledMethod
		classPool: 	a Dictionary(#LargeFrame->56 #SmallFrame->16 )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'
		traitComposition: 	{}
		localSelectors: 	nil


CompiledMethod class>>primitive:numArgs:numTemps:stackSize:literals:bytecodes:trailer:
	Receiver: CompiledMethod
	Arguments and temporary variables: 
		primNum: 	0
		numArgs: 	0
		numTemps: 	5
		stackSize: 	4
		literals: 	an Array(#MooseModel->MooseModel #MultiByteFileStream->MultiByteFileS...etc...
		bytecodes: 	#[138 1 108 64 204 105 65 66 35 228 229 104 17 16 230 135 17 194 117...etc...
		trailerBytes: 	a CompiledMethodTrailer
		compiledMethod: 	nil
	Receiver's instance variables: 
		superclass: 	ByteArray
		methodDict: 	a MethodDictionary(size 231)
		format: 	3586
		layout: 	a CompiledMethodLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CompiledMethod
		classPool: 	a Dictionary(#LargeFrame->56 #SmallFrame->16 )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'
		traitComposition: 	{}
		localSelectors: 	nil


IRBytecodeGenerator>>compiledMethodWith:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		cm: 	nil
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 320)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 320)
		jumps: 	an IdentityDictionary(size 320)
		literals: 	an Array(#MooseModel->MooseModel #MultiByteFileStream->MultiByteFileS...etc...
		lastLiteral: 	nil
		currentSeqId: 	313
		currentSeqNum: 	320
		bytes: 	an OrderedCollection(76 132 96 252 202 135)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 320)
		instrMap: 	an OrderedCollection(an IRTempAccess->1 an IRPushLiteral->2 an IRPush...etc...
		stacks: 	an IdentityDictionary(size 320)
		stack: 	an IRStackCount start 0 stop 0 max 3
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	#(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRTranslator>>compiledMethod
	Receiver: an IRTranslator
	Arguments and temporary variables: 

	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRReturn
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 19950)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 19950)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 19950)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 19950)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(362807296)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(362807296)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [ :morph | morph doIt ]
 #parent on Cmd + Shift + P do [ :morph ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	1
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [ :morph | morph doIt ]
 nil #parent on Cmd...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(362807296)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(362807296)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a PluggableTextMorph(362807296)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a PluggableTextMorph(362807296)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(362807296)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil



--- The full stack ---
CompiledMethod class(Object)>>error:
CompiledMethod class>>newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:
CompiledMethod class>>primitive:numArgs:numTemps:stackSize:literals:bytecodes:trailer:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslator>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:10:39.757334 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=False'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 325)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 325)
		jumps: 	an IdentityDictionary(size 325)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	318
		currentSeqNum: 	325
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 325)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 326)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=False'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=False')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=False'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=False')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (318)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (318)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	318
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (318)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	318
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	334
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21456)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: too many literals (>256)
2 October 2014 4:16:24.793641 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'too many literals (>256)'
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 324)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 324)
		jumps: 	an IdentityDictionary(size 324)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	317
		currentSeqNum: 	324
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 324)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 325)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


IRBytecodeGenerator>>pushLiteral:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		object: 	'83.dependOn(121)=True'
		index: 	257
		interval: 	(32 to: 63)
	Receiver's instance variables: 
		seqOrder: 	an IdentityDictionary(size 324)
		orderSeq: 	an OrderedCollection(an Object 1 2 3 an Object 4 5 an Object 6 an Obj...etc...
		seqBytes: 	an IdentityDictionary(size 324)
		jumps: 	an IdentityDictionary(size 324)
		literals: 	an OCLiteralList(#MooseModel->MooseModel #MultiByteFileStream->MultiB...etc...
		lastLiteral: 	nil
		currentSeqId: 	317
		currentSeqNum: 	324
		bytes: 	an OrderedCollection(76)
		lastSpecialReturn: 	nil
		instrMaps: 	an IdentityDictionary(size 324)
		instrMap: 	an OrderedCollection(an IRLiteralVariableAccess->1)
		stacks: 	an IdentityDictionary(size 325)
		stack: 	an IRStackCount start 0 stop 2 max 2
		primNum: 	0
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	5
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		forceLongForm: 	false


Message>>sendTo:
	Receiver: pushLiteral: '83.dependOn(121)=True'
	Arguments and temporary variables: 
		receiver: 	an IRBytecodeGenerator
	Receiver's instance variables: 
		selector: 	#pushLiteral:
		args: 	#('83.dependOn(121)=True')
		lookupClass: 	nil


IRTranslator>>doPending
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		assoc: 	an IRPushLiteral->pushLiteral: '83.dependOn(121)=True'
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>send:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		selector: 	#value:
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRSend>>executeOn:
	Receiver: an IRSend
	Arguments and temporary variables: 
		interpreter: 	an IRTranslator
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(printResult value: '83.dependOn(121)=True')
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (317)
		selector: 	#value:
		superOf: 	nil


IRTranslator(IRInterpreter)>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irInstruction: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (317)
		instr: 	an IRSend
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop an IRJ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(an IRLiteralVariableAccess an IRPushLiteral an IRSend an IRPop ...etc...
		firstIndex: 	1
		lastIndex: 	5


IRSequence>>do:
	Receiver: an IRSequence (317)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self interpretInstruction: instr ]
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(an IRLiteralVariableAccess an IRPushLiteral an I...etc...
		orderNumber: 	317
		method: 	an IRMethod


IRTranslator(IRInterpreter)>>interpretSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (317)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
		seq: 	an IRSequence (317)
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequence (4)...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :seq | self interpretSequence: seq ]
		index: 	317
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2) an IRSequence (3) an IRSequ...etc...
		firstIndex: 	1
		lastIndex: 	334
		sortBlock: 	[ :x :y | x orderNumber <= y orderNumber ]


IRTranslator(IRInterpreter)>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpretAll:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2) an IRSequen...etc...
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator(IRInterpreter)>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRTranslator>>interpret:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMethod
	Receiver's instance variables: 
		pending: 	an OrderedCollection()
		gen: 	an IRBytecodeGenerator
		currentInstr: 	an IRSend
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack(an IRTempVector an IRTempVector)
		compilationContext: 	a CompilationContext


IRMethod>>generate:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		irTranslator: 	nil
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledMethodWith:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		sourceNode: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel :=...etc...
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary('0vector0'->5 #hasDependency->4 #mooseModel->2 #out->3 #s...etc...
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


RBMethodNode>>generate:
	Receiver: DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseModel new.
	strea...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
	Receiver's instance variables: 
		parent: 	nil
		comments: 	nil
		properties: 	a SmallDictionary(#ir->an IRMethod)
		scope: 	an OCMethodScope 3
		selector: 	#DoIt
		selectorParts: 	an Array( RBIdentifierToken('DoIt'))
		body: 	RBSequenceNode(| stream mooseModel out result hasDependency |
mooseModel ...etc...
		source: 	nil
		arguments: 	#()
		pragmas: 	nil
		replacements: 	a SortedCollection()
		nodeReplacements: 	an IdentityDictionary()
		compilationContext: 	a CompilationContext


[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
self compilationContext requestor
	ifNotNil: [ 
...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>compile
		startpc: 	89
		numArgs: 	0


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		cm: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


[ self compile ] in OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


BlockClosure>>on:do:
	Receiver: [ self compile ]
	Arguments and temporary variables: 
		exception: 	ReparseAfterSourceEditing
		handlerAction: 	[ :ex | 
self source: ex newSource readStream.
self compile ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>translate
		startpc: 	41
		numArgs: 	0


OpalCompiler>>translate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel out result hasDependency| 
mooseModel := M...etc...
		itsSelection: 	a Text for '| stream mooseModel out result hasDependency| 
mooseM...etc...
		itsSelectionString: 	'| stream mooseModel out result hasDependency| 
mooseModel ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(757071872)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21464)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21464)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(757071872)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1329@4505)
		owner: 	a TransformMorph(675545088)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1329@4505)
		color: 	NewColor black
		extension: 	a MorphExtension (793772032) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency| 
mooseModel := ...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(362807296)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21464)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(362807296)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(75.0@89.0) corner: (1423.0@716.0)
		owner: 	a SystemWindow(228851712)
		submorphs: 	an Array(a ScrollBar(402653184) a TransformMorph(675545088))
		fullBounds: 	(75@89) corner: (1423@716)
		color: 	NewColor white
		extension: 	a MorphExtension (735838208) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(402653184)
		scroller: 	a TransformMorph(675545088)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(791412736)
		textMorph: 	a TextMorphForEditView(757071872)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 21464)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(362807296)
		secondArg: 	a PluggableTextMorph(362807296)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>pushLiteral:
Message>>sendTo:
IRTranslator>>doPending
IRTranslator>>send:
IRSend>>executeOn:
IRTranslator(IRInterpreter)>>interpretInstruction:
IRTranslator>>interpretInstruction:
[ :instr | self interpretInstruction: instr ] in IRTranslator(IRInterpreter)>>interpretSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRInterpreter)>>interpretSequence:
[ :seq | self interpretSequence: seq ] in IRTranslator(IRInterpreter)>>interpretAll:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRInterpreter)>>interpretAll:
IRTranslator>>interpretAll:
IRTranslator(IRInterpreter)>>interpret:
IRTranslator>>interpret:
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ 
ast := self parse.
self doSemanticAnalysis.
cm := ast generate: self compilationContext compiledMethodTrailer ] in OpalCompiler>>compile
BlockClosure>>on:do:
OpalCompiler>>compile
[ self compile ] in OpalCompiler>>translate
BlockClosure>>on:do:
OpalCompiler>>translate
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Warning
2 October 2014 4:20:42.366504 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

MorphicUIManager>>warningDefaultAction:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		anException: 	Warning: More than 256 literals referenced. 
You must split or oth...etc...
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


Warning>>defaultAction
	Receiver: Warning: More than 256 literals referenced. 
You must split or otherwise simplify this met...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'More than 256 literals referenced. 
You must split or otherwise s...etc...
		tag: 	nil
		signaler: 	a PluggableTextMorphWithLimits(800849920)
		signalContext: 	Warning(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	Warning: More than 256 literals referenced. 
You must split or other...etc...
	Receiver's instance variables: 
nil

MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Warning: More than 256 literals referenced. 
You must split or other...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	WorldMorph(PasteUpMorph)>>becomeActiveDuring:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[...]


Warning(Exception)>>signal
	Receiver: Warning: More than 256 literals referenced. 
You must split or otherwise simplify this met...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'More than 256 literals referenced. 
You must split or otherwise s...etc...
		tag: 	nil
		signaler: 	a PluggableTextMorphWithLimits(800849920)
		signalContext: 	Warning(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


Warning(Exception)>>signal:
	Receiver: Warning: More than 256 literals referenced. 
You must split or otherwise simplify this met...etc...
	Arguments and temporary variables: 
		signalerText: 	'More than 256 literals referenced. 
You must split or otherwise ...etc...
	Receiver's instance variables: 
		messageText: 	'More than 256 literals referenced. 
You must split or otherwise s...etc...
		tag: 	nil
		signaler: 	a PluggableTextMorphWithLimits(800849920)
		signalContext: 	Warning(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


Warning class(Exception class)>>signal:
	Receiver: Warning
	Arguments and temporary variables: 
		message: 	'More than 256 literals referenced. 
You must split or otherwise simpl...etc...
	Receiver's instance variables: 
		superclass: 	Notification
		methodDict: 	a MethodDictionary(#defaultAction->Warning>>#defaultAction #sunitAn...etc...
		format: 	142
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{UndeclaredVariableWarning. Deprecation. MCMergeOrLoadWarning. Slot...etc...
		name: 	#Warning
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PluggableTextMorphWithLimits(Object)>>notify:
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		aString: 	'More than 256 literals referenced. 
You must split or otherwise simpl...etc...
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(326 to: 325)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


EncoderForV3PlusClosures(Encoder)>>notify:
	Receiver: {an EncoderForV3PlusClosures}
	Arguments and temporary variables: 
		string: 	'More than 256 literals referenced. 
You must split or otherwise simpli...etc...
		req: 	a PluggableTextMorphWithLimits(800849920)
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		scopeTable: 	a Dictionary('c'->{c} 'false'->{false} 'from'->{from} 'fromEntity'-...etc...
		nTemps: 	16
		supered: 	false
		requestor: 	nil
		class: 	Test
		selector: 	#test
		literalStream: 	a WriteStream
		selectorSet: 	a Dictionary(#*->{*} #+->{+} #,->{,} #-->{-} #/->{/} #'//'->{//} #...etc...
		litIndSet: 	a Dictionary(#FileStream->FileStream->{FileStream} #MooseModel->Moos...etc...
		litSet: 	a LiteralDictionary(size 250)
		sourceRanges: 	a Dictionary(size 906)
		globalSourceRanges: 	an OrderedCollection({'MooseModel'. (76 to: 85). false} {'M...etc...
		addedSelectorAndMethodClassLiterals: 	false
		optimizedSelectors: 	a Set(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		stream: 	{an EncoderForV3PlusClosures}
		position: 	1
		rootNode: 	test
	| stream mooseModel hasDependency printResult result |
	<0-26> ...etc...
		blockExtentsToLocals: 	nil


EncoderForV3PlusClosures(Encoder)>>litIndex:
	Receiver: {an EncoderForV3PlusClosures}
	Arguments and temporary variables: 
		literal: 	'83.dependOn(121)=True'
		p: 	256
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		scopeTable: 	a Dictionary('c'->{c} 'false'->{false} 'from'->{from} 'fromEntity'-...etc...
		nTemps: 	16
		supered: 	false
		requestor: 	nil
		class: 	Test
		selector: 	#test
		literalStream: 	a WriteStream
		selectorSet: 	a Dictionary(#*->{*} #+->{+} #,->{,} #-->{-} #/->{/} #'//'->{//} #...etc...
		litIndSet: 	a Dictionary(#FileStream->FileStream->{FileStream} #MooseModel->Moos...etc...
		litSet: 	a LiteralDictionary(size 250)
		sourceRanges: 	a Dictionary(size 906)
		globalSourceRanges: 	an OrderedCollection({'MooseModel'. (76 to: 85). false} {'M...etc...
		addedSelectorAndMethodClassLiterals: 	false
		optimizedSelectors: 	a Set(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		stream: 	{an EncoderForV3PlusClosures}
		position: 	1
		rootNode: 	test
	| stream mooseModel hasDependency printResult result |
	<0-26> ...etc...
		blockExtentsToLocals: 	nil


LiteralNode(LeafNode)>>reserve:
	Receiver: {'83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		key: 	'83.dependOn(121)=True'
		code: 	-3
		index: 	nil


LiteralNode>>sizeCodeForValue:
	Receiver: {'83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		key: 	'83.dependOn(121)=True'
		code: 	-3
		index: 	nil


[...] in MessageNode>>sizeCodeForValue:
	Receiver: {printResult value: '83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		total: 	2
		arg: 	{'83.dependOn(121)=True'}
		argSize: 	nil
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{printResult}
		selector: 	{value:}
		precedence: 	3
		special: 	0
		arguments: 	an OrderedCollection({'83.dependOn(121)=True'})
		sizes: 	#(nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#value:
		originalArguments: 	an OrderedCollection({'83.dependOn(121)=True'})


OrderedCollection>>collect:
	Receiver: an OrderedCollection({'83.dependOn(121)=True'})
	Arguments and temporary variables: 
		aBlock: 	[...]
		newCollection: 	an OrderedCollection()
		index: 	1
	Receiver's instance variables: 
		array: 	an Array({'83.dependOn(121)=True'} nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


MessageNode>>sizeCodeForValue:
	Receiver: {printResult value: '83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		total: 	2
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{printResult}
		selector: 	{value:}
		precedence: 	3
		special: 	0
		arguments: 	an OrderedCollection({'83.dependOn(121)=True'})
		sizes: 	#(nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#value:
		originalArguments: 	an OrderedCollection({'83.dependOn(121)=True'})


MessageNode(ParseNode)>>sizeCodeForBlockValue:
	Receiver: {printResult value: '83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{printResult}
		selector: 	{value:}
		precedence: 	3
		special: 	0
		arguments: 	an OrderedCollection({'83.dependOn(121)=True'})
		sizes: 	#(nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#value:
		originalArguments: 	an OrderedCollection({'83.dependOn(121)=True'})


BlockNode>>sizeCodeForEvaluatedValue:
	Receiver: {[printResult value: '83.dependOn(121)=True']}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		arguments: 	an OrderedCollection()
		statements: 	an OrderedCollection({printResult value: '83.dependOn(121)=True'})
		returns: 	false
		nArgsNode: 	nil
		size: 	nil
		remoteCopyNode: 	nil
		temporaries: 	#()
		optimized: 	true
		optimizedMessageNode: 	{(hasDependency value: #'org.jhotdraw.application' value:...etc...
		actualScopeIfOptimized: 	{[| stream mooseModel hasDependency printResult result ...etc...
		blockExtent: 	nil
		remoteTempNode: 	nil
		copiedValues: 	nil
		closureCreationNode: 	{a LeafNode}
		startOfLastStatement: 	20188


MessageNode>>sizeCodeForIf:value:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		forValue: 	true
		thenExpr: 	{[printResult value: '83.dependOn(121)=True']}
		elseExpr: 	{[printResult value: '83.dependOn(121)=False']}
		branchSize: 	nil
		thenSize: 	nil
		elseSize: 	5
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


MessageNode>>sizeCodeForValue:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		total: 	nil
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


MessageNode(ParseNode)>>sizeCodeForEffect:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


MessageNode>>sizeCodeForIf:value:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		forValue: 	false
		thenExpr: 	{[printResult value: '83.dependOn(121)=True']}
		elseExpr: 	{[printResult value: '83.dependOn(121)=False']}
		branchSize: 	nil
		thenSize: 	nil
		elseSize: 	nil
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


MessageNode>>sizeCodeForEffect:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


BlockNode>>sizeCodeExceptLast:
	Receiver: {[| stream mooseModel hasDependency printResult result |
<0-26> := a NewArrayNode.
	mooseM...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		codeSize: 	2120
		i: 	113
		statement: 	{(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotd...etc...
		iLimiT: 	108
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		arguments: 	#()
		statements: 	an OrderedCollection({<0-26> := a NewArrayNode} {mooseModel := Moos...etc...
		returns: 	true
		nArgsNode: 	nil
		size: 	nil
		remoteCopyNode: 	nil
		temporaries: 	an OrderedCollection({stream} {mooseModel} {hasDependency} {printR...etc...
		optimized: 	false
		optimizedMessageNode: 	nil
		actualScopeIfOptimized: 	nil
		blockExtent: 	(0 to: 26)
		remoteTempNode: 	{<0-26>}
		copiedValues: 	nil
		closureCreationNode: 	nil
		startOfLastStatement: 	21297


BlockNode>>sizeCodeForEvaluatedValue:
	Receiver: {[| stream mooseModel hasDependency printResult result |
<0-26> := a NewArrayNode.
	mooseM...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		arguments: 	#()
		statements: 	an OrderedCollection({<0-26> := a NewArrayNode} {mooseModel := Moos...etc...
		returns: 	true
		nArgsNode: 	nil
		size: 	nil
		remoteCopyNode: 	nil
		temporaries: 	an OrderedCollection({stream} {mooseModel} {hasDependency} {printR...etc...
		optimized: 	false
		optimizedMessageNode: 	nil
		actualScopeIfOptimized: 	nil
		blockExtent: 	(0 to: 26)
		remoteTempNode: 	{<0-26>}
		copiedValues: 	nil
		closureCreationNode: 	nil
		startOfLastStatement: 	21297


MethodNode>>generate:
	Receiver: test
	| stream mooseModel hasDependency printResult result |
	<0-26> := a NewArrayNode.
	m...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		primErrNode: 	nil
		blkSize: 	nil
		nLits: 	nil
		literals: 	nil
		stack: 	nil
		method: 	nil
		locals: 	nil
		lit: 	nil
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		selectorOrFalse: 	#test
		precedence: 	1
		arguments: 	#()
		block: 	{[| stream mooseModel hasDependency printResult result |
<0-26> := a New...etc...
		primitive: 	0
		encoder: 	{an EncoderForV3PlusClosures}
		temporaries: 	an Array({stream} {mooseModel} {hasDependency} {printResult} {<0-2...etc...
		properties: 	an AdditionalMethodState (314310656)
		sourceText: 	'test

| stream mooseModel result hasDependency printResult| 
moose...etc...
		locationCounter: 	27
		localsPool: 	an IdentitySet({n} {hasDependency} {<0-26>} {stream} {mooseModel} {...etc...


Compiler>>compile
	Receiver: a Compiler
	Arguments and temporary variables: 
		methodNode: 	test
	| stream mooseModel hasDependency printResult result |
	<0-26...etc...
	Receiver's instance variables: 
		sourceStream: 	a ReadStream
		requestor: 	a PluggableTextMorphWithLimits(800849920)
		receiver: 	nil
		class: 	Test
		category: 	#'as yet unclassified'
		context: 	nil
		parser: 	a Parser
		compilationContext: 	a CCompilationContext
		compilationContextClass: 	nil


Test class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
	Receiver: Test
	Arguments and temporary variables: 
		text: 	'test

| stream mooseModel out result hasDependency printResult| 
mooseMo...etc...
		category: 	#'as yet unclassified'
		changeStamp: 	'AC 10/2/2014 16:20'
		requestor: 	a PluggableTextMorphWithLimits(800849920)
		logSource: 	true
		method: 	nil
		r: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Test
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#_UnpackagedPackage
		traitComposition: 	{}
		localSelectors: 	nil


Test class(ClassDescription)>>compile:classified:withStamp:notifying:
	Receiver: Test
	Arguments and temporary variables: 
		text: 	'test

| stream mooseModel out result hasDependency printResult| 
mooseMo...etc...
		category: 	#'as yet unclassified'
		changeStamp: 	'AC 10/2/2014 16:20'
		requestor: 	a PluggableTextMorphWithLimits(800849920)
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Test
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#_UnpackagedPackage
		traitComposition: 	{}
		localSelectors: 	nil


Test class(ClassDescription)>>compile:classified:notifying:
	Receiver: Test
	Arguments and temporary variables: 
		text: 	'test

| stream mooseModel out result hasDependency printResult| 
mooseMo...etc...
		category: 	#'as yet unclassified'
		requestor: 	a PluggableTextMorphWithLimits(800849920)
		stamp: 	'AC 10/2/2014 16:20'
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Test
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#_UnpackagedPackage
		traitComposition: 	{}
		localSelectors: 	nil


PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	Test
		aCategory: 	#'as yet unclassified'
		aString: 	'test

| stream mooseModel out result hasDependency printResult| 
moos...etc...
		aController: 	a PluggableTextMorphWithLimits(800849920)
		selector: 	#test
		existingMethod: 	nil
		targetClass: 	Test
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(542900224)
		hierarchyClass: 	Test
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(800849920)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Test->true )
		list: 	a MorphTreeMorph(253493248)
		list2: 	a PluggableIconListMorph(762839040)
		sourceCodePanel: 	a PanelMorph(639107072)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(296484864)
		list2Elements: 	{Test}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(800849920)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1054867456)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(115081216)


PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#'no messages'
		aString: 	'test

| stream mooseModel out result hasDependency printResult| 
moos...etc...
		aController: 	a PluggableTextMorphWithLimits(800849920)
		category: 	#'as yet unclassified'
		selector: 	nil
		class: 	Test
		scroll: 	0.0
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(542900224)
		hierarchyClass: 	Test
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(800849920)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Test->true )
		list: 	a MorphTreeMorph(253493248)
		list2: 	a PluggableIconListMorph(762839040)
		sourceCodePanel: 	a PanelMorph(639107072)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(296484864)
		list2Elements: 	{Test}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(800849920)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1054867456)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(115081216)


MethodDefinitionAcceptor>>accept:notifying:
	Receiver: a MethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	'test

| stream mooseModel out result hasDependency printResult| 
moose...etc...
		aController: 	a PluggableTextMorphWithLimits(800849920)
		protocol: 	#'no messages'
		method: 	nil
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'test

| stream mooseModel out result hasDependency printResu...etc...
		aController: 	a PluggableTextMorphWithLimits(800849920)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(542900224)
		hierarchyClass: 	Test
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(800849920)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Test->true )
		list: 	a MorphTreeMorph(253493248)
		list2: 	a PluggableIconListMorph(762839040)
		sourceCodePanel: 	a PanelMorph(639107072)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(296484864)
		list2Elements: 	{Test}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(800849920)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1054867456)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(115081216)


[...] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'test

| stream mooseModel out result hasDependency pr...etc...
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(326 to: 325)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [...]
	Arguments and temporary variables: 
		aBlock: 	[...]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'test

| stream mooseModel out result hasDependency pr...etc...
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(326 to: 325)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(330 to: 329)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(326 to: 325)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(326 to: 325)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(326 to: 325)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:



--- The full stack ---
MorphicUIManager>>warningDefaultAction:
Warning>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
Warning(Exception)>>signal
Warning(Exception)>>signal:
Warning class(Exception class)>>signal:
PluggableTextMorphWithLimits(Object)>>notify:
EncoderForV3PlusClosures(Encoder)>>notify:
EncoderForV3PlusClosures(Encoder)>>litIndex:
LiteralNode(LeafNode)>>reserve:
LiteralNode>>sizeCodeForValue:
[...] in MessageNode>>sizeCodeForValue:
OrderedCollection>>collect:
MessageNode>>sizeCodeForValue:
MessageNode(ParseNode)>>sizeCodeForBlockValue:
BlockNode>>sizeCodeForEvaluatedValue:
MessageNode>>sizeCodeForIf:value:
MessageNode>>sizeCodeForValue:
MessageNode(ParseNode)>>sizeCodeForEffect:
MessageNode>>sizeCodeForIf:value:
MessageNode>>sizeCodeForEffect:
BlockNode>>sizeCodeExceptLast:
BlockNode>>sizeCodeForEvaluatedValue:
MethodNode>>generate:
Compiler>>compile
Test class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
Test class(ClassDescription)>>compile:classified:withStamp:notifying:
Test class(ClassDescription)>>compile:classified:notifying:
PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
MethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[...] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView>>acceptContents
[...] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[...] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[...] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[...] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[...] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[...] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[...] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[...] in MorphicUIManager>>spawnNewProcess
[...] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Warning
2 October 2014 4:20:55.615757 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

MorphicUIManager>>warningDefaultAction:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		anException: 	Warning: More than 256 literals referenced. 
You must split or oth...etc...
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


Warning>>defaultAction
	Receiver: Warning: More than 256 literals referenced. 
You must split or otherwise simplify this met...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'More than 256 literals referenced. 
You must split or otherwise s...etc...
		tag: 	nil
		signaler: 	a PluggableTextMorphWithLimits(800849920)
		signalContext: 	Warning(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	Warning: More than 256 literals referenced. 
You must split or other...etc...
	Receiver's instance variables: 
nil

MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Warning: More than 256 literals referenced. 
You must split or other...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	WorldMorph(PasteUpMorph)>>becomeActiveDuring:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[...]


Warning(Exception)>>signal
	Receiver: Warning: More than 256 literals referenced. 
You must split or otherwise simplify this met...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'More than 256 literals referenced. 
You must split or otherwise s...etc...
		tag: 	nil
		signaler: 	a PluggableTextMorphWithLimits(800849920)
		signalContext: 	Warning(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


Warning(Exception)>>signal:
	Receiver: Warning: More than 256 literals referenced. 
You must split or otherwise simplify this met...etc...
	Arguments and temporary variables: 
		signalerText: 	'More than 256 literals referenced. 
You must split or otherwise ...etc...
	Receiver's instance variables: 
		messageText: 	'More than 256 literals referenced. 
You must split or otherwise s...etc...
		tag: 	nil
		signaler: 	a PluggableTextMorphWithLimits(800849920)
		signalContext: 	Warning(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


Warning class(Exception class)>>signal:
	Receiver: Warning
	Arguments and temporary variables: 
		message: 	'More than 256 literals referenced. 
You must split or otherwise simpl...etc...
	Receiver's instance variables: 
		superclass: 	Notification
		methodDict: 	a MethodDictionary(#defaultAction->Warning>>#defaultAction #sunitAn...etc...
		format: 	142
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{UndeclaredVariableWarning. Deprecation. MCMergeOrLoadWarning. Slot...etc...
		name: 	#Warning
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PluggableTextMorphWithLimits(Object)>>notify:
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		aString: 	'More than 256 literals referenced. 
You must split or otherwise simpl...etc...
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(343 to: 342)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


EncoderForV3PlusClosures(Encoder)>>notify:
	Receiver: {an EncoderForV3PlusClosures}
	Arguments and temporary variables: 
		string: 	'More than 256 literals referenced. 
You must split or otherwise simpli...etc...
		req: 	a PluggableTextMorphWithLimits(800849920)
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		scopeTable: 	a Dictionary('c'->{c} 'false'->{false} 'from'->{from} 'fromEntity'-...etc...
		nTemps: 	16
		supered: 	false
		requestor: 	nil
		class: 	Test
		selector: 	#test
		literalStream: 	a WriteStream
		selectorSet: 	a Dictionary(#*->{*} #+->{+} #,->{,} #-->{-} #/->{/} #'//'->{//} #...etc...
		litIndSet: 	a Dictionary(#FileStream->FileStream->{FileStream} #MooseModel->Moos...etc...
		litSet: 	a LiteralDictionary(size 250)
		sourceRanges: 	a Dictionary(size 906)
		globalSourceRanges: 	an OrderedCollection({'MooseModel'. (76 to: 85). false} {'M...etc...
		addedSelectorAndMethodClassLiterals: 	false
		optimizedSelectors: 	a Set(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		stream: 	{an EncoderForV3PlusClosures}
		position: 	1
		rootNode: 	test
	| stream mooseModel hasDependency printResult result |
	<0-26> ...etc...
		blockExtentsToLocals: 	nil


EncoderForV3PlusClosures(Encoder)>>litIndex:
	Receiver: {an EncoderForV3PlusClosures}
	Arguments and temporary variables: 
		literal: 	'83.dependOn(121)=True'
		p: 	256
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		scopeTable: 	a Dictionary('c'->{c} 'false'->{false} 'from'->{from} 'fromEntity'-...etc...
		nTemps: 	16
		supered: 	false
		requestor: 	nil
		class: 	Test
		selector: 	#test
		literalStream: 	a WriteStream
		selectorSet: 	a Dictionary(#*->{*} #+->{+} #,->{,} #-->{-} #/->{/} #'//'->{//} #...etc...
		litIndSet: 	a Dictionary(#FileStream->FileStream->{FileStream} #MooseModel->Moos...etc...
		litSet: 	a LiteralDictionary(size 250)
		sourceRanges: 	a Dictionary(size 906)
		globalSourceRanges: 	an OrderedCollection({'MooseModel'. (76 to: 85). false} {'M...etc...
		addedSelectorAndMethodClassLiterals: 	false
		optimizedSelectors: 	a Set(#ifTrue:ifFalse: #ifNotNil: #ifTrue:)
		stream: 	{an EncoderForV3PlusClosures}
		position: 	1
		rootNode: 	test
	| stream mooseModel hasDependency printResult result |
	<0-26> ...etc...
		blockExtentsToLocals: 	nil


LiteralNode(LeafNode)>>reserve:
	Receiver: {'83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		key: 	'83.dependOn(121)=True'
		code: 	-3
		index: 	nil


LiteralNode>>sizeCodeForValue:
	Receiver: {'83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		key: 	'83.dependOn(121)=True'
		code: 	-3
		index: 	nil


[...] in MessageNode>>sizeCodeForValue:
	Receiver: {printResult value: '83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		total: 	2
		arg: 	{'83.dependOn(121)=True'}
		argSize: 	nil
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{printResult}
		selector: 	{value:}
		precedence: 	3
		special: 	0
		arguments: 	an OrderedCollection({'83.dependOn(121)=True'})
		sizes: 	#(nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#value:
		originalArguments: 	an OrderedCollection({'83.dependOn(121)=True'})


OrderedCollection>>collect:
	Receiver: an OrderedCollection({'83.dependOn(121)=True'})
	Arguments and temporary variables: 
		aBlock: 	[...]
		newCollection: 	an OrderedCollection()
		index: 	1
	Receiver's instance variables: 
		array: 	an Array({'83.dependOn(121)=True'} nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


MessageNode>>sizeCodeForValue:
	Receiver: {printResult value: '83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		total: 	2
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{printResult}
		selector: 	{value:}
		precedence: 	3
		special: 	0
		arguments: 	an OrderedCollection({'83.dependOn(121)=True'})
		sizes: 	#(nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#value:
		originalArguments: 	an OrderedCollection({'83.dependOn(121)=True'})


MessageNode(ParseNode)>>sizeCodeForBlockValue:
	Receiver: {printResult value: '83.dependOn(121)=True'}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{printResult}
		selector: 	{value:}
		precedence: 	3
		special: 	0
		arguments: 	an OrderedCollection({'83.dependOn(121)=True'})
		sizes: 	#(nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#value:
		originalArguments: 	an OrderedCollection({'83.dependOn(121)=True'})


BlockNode>>sizeCodeForEvaluatedValue:
	Receiver: {[printResult value: '83.dependOn(121)=True']}
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		arguments: 	an OrderedCollection()
		statements: 	an OrderedCollection({printResult value: '83.dependOn(121)=True'})
		returns: 	false
		nArgsNode: 	nil
		size: 	nil
		remoteCopyNode: 	nil
		temporaries: 	#()
		optimized: 	true
		optimizedMessageNode: 	{(hasDependency value: #'org.jhotdraw.application' value:...etc...
		actualScopeIfOptimized: 	{[| stream mooseModel hasDependency printResult result ...etc...
		blockExtent: 	nil
		remoteTempNode: 	nil
		copiedValues: 	nil
		closureCreationNode: 	{a LeafNode}
		startOfLastStatement: 	20188


MessageNode>>sizeCodeForIf:value:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		forValue: 	true
		thenExpr: 	{[printResult value: '83.dependOn(121)=True']}
		elseExpr: 	{[printResult value: '83.dependOn(121)=False']}
		branchSize: 	nil
		thenSize: 	nil
		elseSize: 	5
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


MessageNode>>sizeCodeForValue:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		total: 	nil
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


MessageNode(ParseNode)>>sizeCodeForEffect:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


MessageNode>>sizeCodeForIf:value:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		forValue: 	false
		thenExpr: 	{[printResult value: '83.dependOn(121)=True']}
		elseExpr: 	{[printResult value: '83.dependOn(121)=False']}
		branchSize: 	nil
		thenSize: 	nil
		elseSize: 	nil
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


MessageNode>>sizeCodeForEffect:
	Receiver: {(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdraw.test.framework')
	...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		receiver: 	{hasDependency value: #'org.jhotdraw.application' value: 'org.jhotdra...etc...
		selector: 	{ifTrue:ifFalse:}
		precedence: 	3
		special: 	3
		arguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=True']} ...etc...
		sizes: 	#(nil nil)
		equalNode: 	nil
		caseErrorNode: 	nil
		originalSelector: 	#ifTrue:ifFalse:
		originalArguments: 	an OrderedCollection({[printResult value: '83.dependOn(121)=...etc...


BlockNode>>sizeCodeExceptLast:
	Receiver: {[| stream mooseModel hasDependency printResult result |
<0-26> := a NewArrayNode.
	mooseM...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
		codeSize: 	2120
		i: 	113
		statement: 	{(hasDependency value: #'org.jhotdraw.application' value: 'org.jhotd...etc...
		iLimiT: 	108
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		arguments: 	#()
		statements: 	an OrderedCollection({<0-26> := a NewArrayNode} {mooseModel := Moos...etc...
		returns: 	true
		nArgsNode: 	nil
		size: 	nil
		remoteCopyNode: 	nil
		temporaries: 	an OrderedCollection({stream} {mooseModel} {hasDependency} {printR...etc...
		optimized: 	false
		optimizedMessageNode: 	nil
		actualScopeIfOptimized: 	nil
		blockExtent: 	(0 to: 26)
		remoteTempNode: 	{<0-26>}
		copiedValues: 	nil
		closureCreationNode: 	nil
		startOfLastStatement: 	21297


BlockNode>>sizeCodeForEvaluatedValue:
	Receiver: {[| stream mooseModel hasDependency printResult result |
<0-26> := a NewArrayNode.
	mooseM...etc...
	Arguments and temporary variables: 
		encoder: 	{an EncoderForV3PlusClosures}
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		arguments: 	#()
		statements: 	an OrderedCollection({<0-26> := a NewArrayNode} {mooseModel := Moos...etc...
		returns: 	true
		nArgsNode: 	nil
		size: 	nil
		remoteCopyNode: 	nil
		temporaries: 	an OrderedCollection({stream} {mooseModel} {hasDependency} {printR...etc...
		optimized: 	false
		optimizedMessageNode: 	nil
		actualScopeIfOptimized: 	nil
		blockExtent: 	(0 to: 26)
		remoteTempNode: 	{<0-26>}
		copiedValues: 	nil
		closureCreationNode: 	nil
		startOfLastStatement: 	21297


MethodNode>>generate:
	Receiver: test
	| stream mooseModel hasDependency printResult result |
	<0-26> := a NewArrayNode.
	m...etc...
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		primErrNode: 	nil
		blkSize: 	nil
		nLits: 	nil
		literals: 	nil
		stack: 	nil
		method: 	nil
		locals: 	nil
		lit: 	nil
	Receiver's instance variables: 
		comment: 	nil
		pc: 	nil
		selectorOrFalse: 	#test
		precedence: 	1
		arguments: 	#()
		block: 	{[| stream mooseModel hasDependency printResult result |
<0-26> := a New...etc...
		primitive: 	0
		encoder: 	{an EncoderForV3PlusClosures}
		temporaries: 	an Array({stream} {mooseModel} {hasDependency} {printResult} {<0-2...etc...
		properties: 	an AdditionalMethodState (841744384)
		sourceText: 	'test

| stream mooseModel result hasDependency printResult| 
moose...etc...
		locationCounter: 	27
		localsPool: 	an IdentitySet({c} {n} {hasDependency} {msg} {<6-24>} {stream} {moo...etc...


Compiler>>compile
	Receiver: a Compiler
	Arguments and temporary variables: 
		methodNode: 	test
	| stream mooseModel hasDependency printResult result |
	<0-26...etc...
	Receiver's instance variables: 
		sourceStream: 	a ReadStream
		requestor: 	a PluggableTextMorphWithLimits(800849920)
		receiver: 	nil
		class: 	Test
		category: 	#'as yet unclassified'
		context: 	nil
		parser: 	a Parser
		compilationContext: 	a CCompilationContext
		compilationContextClass: 	nil


Test class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
	Receiver: Test
	Arguments and temporary variables: 
		text: 	'test

| stream mooseModel result hasDependency printResult| 
mooseModel ...etc...
		category: 	#'as yet unclassified'
		changeStamp: 	'AC 10/2/2014 16:20'
		requestor: 	a PluggableTextMorphWithLimits(800849920)
		logSource: 	true
		method: 	nil
		r: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Test
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#_UnpackagedPackage
		traitComposition: 	{}
		localSelectors: 	nil


Test class(ClassDescription)>>compile:classified:withStamp:notifying:
	Receiver: Test
	Arguments and temporary variables: 
		text: 	'test

| stream mooseModel result hasDependency printResult| 
mooseModel ...etc...
		category: 	#'as yet unclassified'
		changeStamp: 	'AC 10/2/2014 16:20'
		requestor: 	a PluggableTextMorphWithLimits(800849920)
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Test
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#_UnpackagedPackage
		traitComposition: 	{}
		localSelectors: 	nil


Test class(ClassDescription)>>compile:classified:notifying:
	Receiver: Test
	Arguments and temporary variables: 
		text: 	'test

| stream mooseModel result hasDependency printResult| 
mooseModel ...etc...
		category: 	#'as yet unclassified'
		requestor: 	a PluggableTextMorphWithLimits(800849920)
		stamp: 	'AC 10/2/2014 16:20'
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Test
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#_UnpackagedPackage
		traitComposition: 	{}
		localSelectors: 	nil


PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	Test
		aCategory: 	#'as yet unclassified'
		aString: 	'test

| stream mooseModel result hasDependency printResult| 
mooseMod...etc...
		aController: 	a PluggableTextMorphWithLimits(800849920)
		selector: 	#test
		existingMethod: 	nil
		targetClass: 	Test
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(542900224)
		hierarchyClass: 	Test
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(800849920)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Test->true )
		list: 	a MorphTreeMorph(253493248)
		list2: 	a PluggableIconListMorph(762839040)
		sourceCodePanel: 	a PanelMorph(639107072)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(296484864)
		list2Elements: 	{Test}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(800849920)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1054867456)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(115081216)


PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#'no messages'
		aString: 	'test

| stream mooseModel result hasDependency printResult| 
mooseMod...etc...
		aController: 	a PluggableTextMorphWithLimits(800849920)
		category: 	#'as yet unclassified'
		selector: 	nil
		class: 	Test
		scroll: 	0.0
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(542900224)
		hierarchyClass: 	Test
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(800849920)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Test->true )
		list: 	a MorphTreeMorph(253493248)
		list2: 	a PluggableIconListMorph(762839040)
		sourceCodePanel: 	a PanelMorph(639107072)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(296484864)
		list2Elements: 	{Test}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(800849920)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1054867456)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(115081216)


MethodDefinitionAcceptor>>accept:notifying:
	Receiver: a MethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	'test

| stream mooseModel result hasDependency printResult| 
mooseMode...etc...
		aController: 	a PluggableTextMorphWithLimits(800849920)
		protocol: 	#'no messages'
		method: 	nil
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'test

| stream mooseModel result hasDependency printResult| ...etc...
		aController: 	a PluggableTextMorphWithLimits(800849920)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(542900224)
		hierarchyClass: 	Test
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(800849920)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Test->true )
		list: 	a MorphTreeMorph(253493248)
		list2: 	a PluggableIconListMorph(762839040)
		sourceCodePanel: 	a PanelMorph(639107072)
		commentTextArea: 	nil
		currentDisplayChoice: 	nil
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(296484864)
		list2Elements: 	{Test}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(800849920)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1054867456)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(115081216)


[...] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'test

| stream mooseModel result hasDependency printR...etc...
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(343 to: 342)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [...]
	Arguments and temporary variables: 
		aBlock: 	[...]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'test

| stream mooseModel result hasDependency printR...etc...
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(343 to: 342)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(343 to: 342)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(343 to: 342)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(343 to: 342)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(800849920)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1051.0@803.0) corner: (2339.0@1292.0)
		owner: 	a MultipleMethodsEditor(1054867456)
		submorphs: 	an Array(a ScrollBar(842530816) an AlphaImageMorph(34340864) a Trans...etc...
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (958136320) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.862 g: 0.862 b: 0.862 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(842530816)
		scroller: 	a TransformMorph(205258752)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(532152320)
		textMorph: 	a TextMorphForEditView(991428608)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(343 to: 342)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	700
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(34340864)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:



--- The full stack ---
MorphicUIManager>>warningDefaultAction:
Warning>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
Warning(Exception)>>signal
Warning(Exception)>>signal:
Warning class(Exception class)>>signal:
PluggableTextMorphWithLimits(Object)>>notify:
EncoderForV3PlusClosures(Encoder)>>notify:
EncoderForV3PlusClosures(Encoder)>>litIndex:
LiteralNode(LeafNode)>>reserve:
LiteralNode>>sizeCodeForValue:
[...] in MessageNode>>sizeCodeForValue:
OrderedCollection>>collect:
MessageNode>>sizeCodeForValue:
MessageNode(ParseNode)>>sizeCodeForBlockValue:
BlockNode>>sizeCodeForEvaluatedValue:
MessageNode>>sizeCodeForIf:value:
MessageNode>>sizeCodeForValue:
MessageNode(ParseNode)>>sizeCodeForEffect:
MessageNode>>sizeCodeForIf:value:
MessageNode>>sizeCodeForEffect:
BlockNode>>sizeCodeExceptLast:
BlockNode>>sizeCodeForEvaluatedValue:
MethodNode>>generate:
Compiler>>compile
Test class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
Test class(ClassDescription)>>compile:classified:withStamp:notifying:
Test class(ClassDescription)>>compile:classified:notifying:
PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
MethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[...] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView>>acceptContents
[...] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[...] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[...] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[...] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[...] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[...] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[...] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[...] in MorphicUIManager>>spawnNewProcess
[...] in BlockClosure>>newProcess
-------------------------------------------------------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoTestSuite/1412260643/DIMooseDependencies-test.st
===============================================================================
THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>tests
2 October 2014 4:37:47.201219 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

Array(Object)>>doesNotUnderstand: #tests
	Receiver: #(#('org.jhotdraw.application' 'org.jhotdraw.contrib' '1.dependOn(2)=True' '1.dependOn(2)=...etc...
	Arguments and temporary variables: 
		aMessage: 	tests
		exception: 	MessageNotUnderstood: Array>>tests
		resumeValue: 	nil
	Receiver's instance variables: 
#(#('org.jhotdraw.application' 'org.jhotdraw.contrib' '1.dependOn(2)=True' '1.dependOn(2)=...etc...

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	''
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		mooseModel: 	a MooseModel #noname(52656)
		out: 	nil
		hasDependency: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel...etc...
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel out result hasDependency |
	mooseModel := MooseM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(| stream mooseModel out result hasDependency| 
mooseModel := MooseModel ...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'| stream mooseModel out result hasDependency| 
mooseModel := MooseMo...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(| stream mooseModel out result hasDependency| 
m...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(| stream mooseModel out result hasDependency| 
moos...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(| stream mooseModel out result hasDependency|...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(| stream mooseModel ou...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysi...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/ana...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/../...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #tests
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>tests
2 October 2014 4:39:03.269555 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

Array(Object)>>doesNotUnderstand: #tests
	Receiver: #(#('org.jhotdraw.application' 'org.jhotdraw.contrib' '1.dependOn(2)=True' '1.dependOn(2)=...etc...
	Arguments and temporary variables: 
		aMessage: 	tests
		exception: 	MessageNotUnderstood: Array>>tests
		resumeValue: 	nil
	Receiver's instance variables: 
#(#('org.jhotdraw.application' 'org.jhotdraw.contrib' '1.dependOn(2)=True' '1.dependOn(2)=...etc...

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		mooseModel: 	a MooseModel #noname(52656)
		out: 	nil
		hasDependency: 	[...]
		printResult: 	[...]
		result: 	''
	Receiver's instance variables: 
nil

Compiler>>evaluate:in:to:notifying:ifFail:logged:
	Receiver: a Compiler
	Arguments and temporary variables: 
		textOrStream: 	a ReadWriteStream
		aContext: 	nil
		aReceiver: 	nil
		aRequestor: 	a TextMorphForEditView(547094528)
		failBlock: 	[...]
		logFlag: 	false
		methodNode: 	DoIt
	| stream mooseModel out hasDependency printResult result |
	<...etc...
		method: 	UndefinedObject>>#DoIt
		value: 	nil
		toLog: 	nil
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		sourceStream: 	a ReadWriteStream
		requestor: 	a TextMorphForEditView(547094528)
		receiver: 	nil
		class: 	UndefinedObject
		category: 	nil
		context: 	nil
		parser: 	a Parser
		compilationContext: 	a CCompilationContext
		compilationContextClass: 	nil


Compiler>>evaluate:
	Receiver: a Compiler
	Arguments and temporary variables: 
		textOrString: 	a ReadWriteStream
	Receiver's instance variables: 
		sourceStream: 	a ReadWriteStream
		requestor: 	a TextMorphForEditView(547094528)
		receiver: 	nil
		class: 	UndefinedObject
		category: 	nil
		context: 	nil
		parser: 	a Parser
		compilationContext: 	a CCompilationContext
		compilationContextClass: 	nil


Compiler>>evaluate
	Receiver: a Compiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		sourceStream: 	a ReadWriteStream
		requestor: 	a TextMorphForEditView(547094528)
		receiver: 	nil
		class: 	UndefinedObject
		category: 	nil
		context: 	nil
		parser: 	a Parser
		compilationContext: 	a CCompilationContext
		compilationContextClass: 	nil


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[...]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(547094528)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(547094528)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[...] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(457703424)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(442.0@134.0) corner: (2492.0@1419.0)
		owner: 	a SystemWindow(200278016)
		submorphs: 	an Array(a ScrollBar(497549312) a TransformMorph(326107136))
		fullBounds: 	(442@134) corner: (2492@1419)
		color: 	NewColor white
		extension: 	a MorphExtension (525860864) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(497549312)
		scroller: 	a TransformMorph(326107136)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(387710976)
		textMorph: 	a TextMorphForEditView(547094528)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 12099)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[...] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(457703424)
	Arguments and temporary variables: 
		editBlock: 	[...]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(442.0@134.0) corner: (2492.0@1419.0)
		owner: 	a SystemWindow(200278016)
		submorphs: 	an Array(a ScrollBar(497549312) a TransformMorph(326107136))
		fullBounds: 	(442@134) corner: (2492@1419)
		color: 	NewColor white
		extension: 	a MorphExtension (525860864) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(497549312)
		scroller: 	a TransformMorph(326107136)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(387710976)
		textMorph: 	a TextMorphForEditView(547094528)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 12099)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		editBlock: 	[...]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult| 
mo...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(457703424)
	Arguments and temporary variables: 
		editBlock: 	[...]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(442.0@134.0) corner: (2492.0@1419.0)
		owner: 	a SystemWindow(200278016)
		submorphs: 	an Array(a ScrollBar(497549312) a TransformMorph(326107136))
		fullBounds: 	(442@134) corner: (2492@1419)
		color: 	NewColor white
		extension: 	a MorphExtension (525860864) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(497549312)
		scroller: 	a TransformMorph(326107136)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(387710976)
		textMorph: 	a TextMorphForEditView(547094528)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 12099)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(457703424)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(442.0@134.0) corner: (2492.0@1419.0)
		owner: 	a SystemWindow(200278016)
		submorphs: 	an Array(a ScrollBar(497549312) a TransformMorph(326107136))
		fullBounds: 	(442@134) corner: (2492@1419)
		color: 	NewColor white
		extension: 	a MorphExtension (525860864) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(497549312)
		scroller: 	a TransformMorph(326107136)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(387710976)
		textMorph: 	a TextMorphForEditView(547094528)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 12099)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[...] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(457703424)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [...]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(457703424)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [...]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(457703424)
		secondArg: 	a PluggableTextMorph(457703424)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [...]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(457703424)
		secondArg: 	a PluggableTextMorph(457703424)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [...]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(457703424)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(457703424)


[...] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [...]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[...]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[...]
		index: 	2
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [...]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[...]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [...]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[...]
	Receiver's instance variables: 
		action: 	[...]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[...] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aMatchListener: 	[...]
		aBlock: 	an OrderedCollection([keystroke '<Cmd-d>'])
		entry: 	#doIt on Cmd + D do [...]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [...]
 #parent on Cmd + Shift + P do [...]
 #previousSelection o...etc...
	Arguments and temporary variables: 
		aBlock: 	[...]
		index: 	23
		each: 	#doIt on Cmd + D do [...]

		indexLimiT: 	1
	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [...]
 nil #parent on Cmd + Shift + P do [....etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[...]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[...]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(457703424)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(457703424)


[...] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a PluggableTextMorph(457703424)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[...]
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a PluggableTextMorph(457703424)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(457703424)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[...] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[...]
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(547094528)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult| 
mo...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult| 
mo...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(547094528)
	Receiver's instance variables: 
		timeStamp: 	2177571
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(723@2595.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult| 
mo...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult| 
mo...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[...] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(547094528)
		aBlock: 	[...]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1160@1383.0) corner: (1176@1399.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(1160@1383.0) corner: (1176@1399.0)
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(547094528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1168@1392) mouseOver nil nil]
		targetOffset: 	(719@2624.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2175536 1168 1392 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
Array(Object)>>doesNotUnderstand: #tests
UndefinedObject>>DoIt
Compiler>>evaluate:in:to:notifying:ifFail:logged:
Compiler>>evaluate:
Compiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[...] in PluggableTextMorph>>doIt
[...] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[...] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[...] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[...] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[...] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[...] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[...] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[...] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[...] in MorphicUIManager>>spawnNewProcess
[...] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>tests
2 October 2014 4:39:44.58129 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

Array(Object)>>doesNotUnderstand: #tests
	Receiver: #(#('org.jhotdraw.application' 'org.jhotdraw.contrib' '1.dependOn(2)=True' '1.dependOn(2)=...etc...
	Arguments and temporary variables: 
		aMessage: 	tests
		exception: 	MessageNotUnderstood: Array>>tests
		resumeValue: 	nil
	Receiver's instance variables: 
#(#('org.jhotdraw.application' 'org.jhotdraw.contrib' '1.dependOn(2)=True' '1.dependOn(2)=...etc...

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		mooseModel: 	a MooseModel #noname(52656)
		out: 	nil
		hasDependency: 	[...]
		printResult: 	[...]
		tests: 	nil
		result: 	''
	Receiver's instance variables: 
nil

Compiler>>evaluate:in:to:notifying:ifFail:logged:
	Receiver: a Compiler
	Arguments and temporary variables: 
		textOrStream: 	a ReadWriteStream
		aContext: 	nil
		aReceiver: 	nil
		aRequestor: 	a TextMorphForEditView(547094528)
		failBlock: 	[...]
		logFlag: 	false
		methodNode: 	DoIt
	| stream mooseModel out hasDependency printResult tests resul...etc...
		method: 	UndefinedObject>>#DoIt
		value: 	nil
		toLog: 	nil
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		sourceStream: 	a ReadWriteStream
		requestor: 	a TextMorphForEditView(547094528)
		receiver: 	nil
		class: 	UndefinedObject
		category: 	nil
		context: 	nil
		parser: 	a Parser
		compilationContext: 	a CCompilationContext
		compilationContextClass: 	nil


Compiler>>evaluate:
	Receiver: a Compiler
	Arguments and temporary variables: 
		textOrString: 	a ReadWriteStream
	Receiver's instance variables: 
		sourceStream: 	a ReadWriteStream
		requestor: 	a TextMorphForEditView(547094528)
		receiver: 	nil
		class: 	UndefinedObject
		category: 	nil
		context: 	nil
		parser: 	a Parser
		compilationContext: 	a CCompilationContext
		compilationContextClass: 	nil


Compiler>>evaluate
	Receiver: a Compiler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		sourceStream: 	a ReadWriteStream
		requestor: 	a TextMorphForEditView(547094528)
		receiver: 	nil
		class: 	UndefinedObject
		category: 	nil
		context: 	nil
		parser: 	a Parser
		compilationContext: 	a CCompilationContext
		compilationContextClass: 	nil


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[...]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(547094528)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(547094528)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[...] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(457703424)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(442.0@134.0) corner: (2492.0@1419.0)
		owner: 	a SystemWindow(200278016)
		submorphs: 	an Array(a ScrollBar(497549312) a TransformMorph(326107136))
		fullBounds: 	(442@134) corner: (2492@1419)
		color: 	NewColor white
		extension: 	a MorphExtension (525860864) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(497549312)
		scroller: 	a TransformMorph(326107136)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(387710976)
		textMorph: 	a TextMorphForEditView(547094528)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 12105)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[...] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(457703424)
	Arguments and temporary variables: 
		editBlock: 	[...]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(442.0@134.0) corner: (2492.0@1419.0)
		owner: 	a SystemWindow(200278016)
		submorphs: 	an Array(a ScrollBar(497549312) a TransformMorph(326107136))
		fullBounds: 	(442@134) corner: (2492@1419)
		color: 	NewColor white
		extension: 	a MorphExtension (525860864) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(497549312)
		scroller: 	a TransformMorph(326107136)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(387710976)
		textMorph: 	a TextMorphForEditView(547094528)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 12105)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		editBlock: 	[...]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult test...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(457703424)
	Arguments and temporary variables: 
		editBlock: 	[...]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(442.0@134.0) corner: (2492.0@1419.0)
		owner: 	a SystemWindow(200278016)
		submorphs: 	an Array(a ScrollBar(497549312) a TransformMorph(326107136))
		fullBounds: 	(442@134) corner: (2492@1419)
		color: 	NewColor white
		extension: 	a MorphExtension (525860864) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(497549312)
		scroller: 	a TransformMorph(326107136)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(387710976)
		textMorph: 	a TextMorphForEditView(547094528)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 12105)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(457703424)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(442.0@134.0) corner: (2492.0@1419.0)
		owner: 	a SystemWindow(200278016)
		submorphs: 	an Array(a ScrollBar(497549312) a TransformMorph(326107136))
		fullBounds: 	(442@134) corner: (2492@1419)
		color: 	NewColor white
		extension: 	a MorphExtension (525860864) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(497549312)
		scroller: 	a TransformMorph(326107136)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(387710976)
		textMorph: 	a TextMorphForEditView(547094528)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 12105)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[...] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(457703424)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [...]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(457703424)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [...]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(457703424)
		secondArg: 	a PluggableTextMorph(457703424)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [...]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(457703424)
		secondArg: 	a PluggableTextMorph(457703424)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [...]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(457703424)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(457703424)


[...] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [...]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[...]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[...]
		index: 	2
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [...]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[...]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [...]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[...]
	Receiver's instance variables: 
		action: 	[...]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[...] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aMatchListener: 	[...]
		aBlock: 	an OrderedCollection([keystroke '<Cmd-d>'])
		entry: 	#doIt on Cmd + D do [...]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#doIt on Cmd + D do [...]
 #parent on Cmd + Shift + P do [...]
 #previousSelection o...etc...
	Arguments and temporary variables: 
		aBlock: 	[...]
		index: 	23
		each: 	#doIt on Cmd + D do [...]

		indexLimiT: 	1
	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#doIt on Cmd + D do [...]
 nil #parent on Cmd + Shift + P do [....etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[...]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[...]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(457703424)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(457703424)


[...] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a PluggableTextMorph(457703424)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[...]
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a PluggableTextMorph(457703424)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(457703424)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[...] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[...]
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(547094528)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult test...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult test...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(547094528)
	Receiver's instance variables: 
		timeStamp: 	2212979
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(437@1348.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult test...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(547094528)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (2031@2624)
		owner: 	a TransformMorph(326107136)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (2031@2624)
		color: 	NewColor black
		extension: 	a MorphExtension (583794688) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel out result hasDependency printResult test...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(457703424)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[...] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(547094528)
		aBlock: 	[...]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(457@1274.0) corner: (473@1290.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(457@1274.0) corner: (473@1290.0)
		color: 	NewColor blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(547094528)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(465@1283) mouseOver nil nil]
		targetOffset: 	(19.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2218936 1091 188 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #tests
UndefinedObject>>DoIt
Compiler>>evaluate:in:to:notifying:ifFail:logged:
Compiler>>evaluate:
Compiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[...] in PluggableTextMorph>>doIt
[...] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[...] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[...] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[...] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[...] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[...] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[...] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[...] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[...] in MorphicUIManager>>spawnNewProcess
[...] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
User Interrupt
3 October 2014 2:32:28.210801 pm

VM: Mac OS - intel - 1094 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 Feb 14 2014
https://github.com/pharo-project/pharo-vm.git Commit: 2dc51fe10f67e2817d93e35aeab5e5c4c1dda33e Date: 2014-02-14 11:56:31 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14801

Image: Pharo3.0 [Latest update: #30767]

OrderedCollection>>at:put:
	Receiver: an OrderedCollection(a FMDanglingReference)
	Arguments and temporary variables: 
		anInteger: 	1
		anObject: 	 (local variable)
	Receiver's instance variables: 
		array: 	an Array(a FMDanglingReference nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


FMDanglingReference>>resolve:
	Receiver: a FMDanglingReference
	Arguments and temporary variables: 
		element: 	 (local variable)
	Receiver's instance variables: 
		to: 	nil
		owner: 	a FMFutureAttribute
		pos: 	1


[ :each | 
each resolve: element.
tally := tally - 1.
tally should >= 0 ] in MSEImporter(FMImporter)>>assign:to:
	Receiver: a MSEImporter
	Arguments and temporary variables: 
		element: 	 (local variable)
		serial: 	22753
		todo: 	an OrderedCollection(a FMDanglingReference a FMDanglingReference)
		each: 	a FMDanglingReference
	Receiver's instance variables: 
		stack: 	a Stack(a FMFutureElement)
		elements: 	an OrderedCollection(UndoableCommandTest>>testCommandNotExecutable() ...etc...
		model: 	a FMRepository
		metamodel: 	a FMMetaRepository
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		tally: 	30088
		reminderDict: 	an IdentityDictionary(size 12423)
		serialDict: 	an IdentityDictionary(size 22752)


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FMDanglingReference a FMDanglingReference)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each resolve: element.
tally := tally - 1.
tally should >= 0...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a FMDanglingReference a FMDanglingReference nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	2


MSEImporter(FMImporter)>>assign:to:
	Receiver: a MSEImporter
	Arguments and temporary variables: 
		element: 	 (local variable)
		serial: 	22753
		todo: 	an OrderedCollection(a FMDanglingReference a FMDanglingReference)
	Receiver's instance variables: 
		stack: 	a Stack(a FMFutureElement)
		elements: 	an OrderedCollection(UndoableCommandTest>>testCommandNotExecutable() ...etc...
		model: 	a FMRepository
		metamodel: 	a FMMetaRepository
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		tally: 	30088
		reminderDict: 	an IdentityDictionary(size 12423)
		serialDict: 	an IdentityDictionary(size 22752)


FMFutureElement>>serial:
	Receiver: a FMFutureElement
	Arguments and temporary variables: 
		serial: 	22753
	Receiver's instance variables: 
		instance: 	 (local variable)
		current: 	nil
		metaDescription: 	a FM3MetaDescription[FAMIX.LocalVariable]
		owner: 	a MSEImporter


MSEImporter(FMImporter)>>serial:
	Receiver: a MSEImporter
	Arguments and temporary variables: 
		serial: 	22753
	Receiver's instance variables: 
		stack: 	a Stack(a FMFutureElement)
		elements: 	an OrderedCollection(UndoableCommandTest>>testCommandNotExecutable() ...etc...
		model: 	a FMRepository
		metamodel: 	a FMMetaRepository
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		tally: 	30088
		reminderDict: 	an IdentityDictionary(size 12423)
		serialDict: 	an IdentityDictionary(size 22752)


FMMSEParser>>Serial
	Receiver: a FMMSEParser
	Arguments and temporary variables: 
		pos: 	3931807
		serial: 	22753
	Receiver's instance variables: 
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		client: 	a MSEImporter
		buf: 	a WriteStream
		char: 	$)
		progBar: 	a Job
		increments: 	22751


FMMSEParser>>Element
	Receiver: a FMMSEParser
	Arguments and temporary variables: 
		pos: 	3931786
		n: 	'FAMIX.LocalVariable'
	Receiver's instance variables: 
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		client: 	a MSEImporter
		buf: 	a WriteStream
		char: 	$)
		progBar: 	a Job
		increments: 	22751


FMMSEParser>>Document
	Receiver: a FMMSEParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		client: 	a MSEImporter
		buf: 	a WriteStream
		char: 	$)
		progBar: 	a Job
		increments: 	22751


FMMSEParser>>basicRun
	Receiver: a FMMSEParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		client: 	a MSEImporter
		buf: 	a WriteStream
		char: 	$)
		progBar: 	a Job
		increments: 	22751


[ :bar | 
progBar := bar.
self basicRun ] in FMMSEParser>>run
	Receiver: a FMMSEParser
	Arguments and temporary variables: 
		bar: 	a Job
	Receiver's instance variables: 
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		client: 	a MSEImporter
		buf: 	a WriteStream
		char: 	$)
		progBar: 	a Job
		increments: 	22751


BlockClosure>>cull:
	Receiver: [ :bar | 
progBar := bar.
self basicRun ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	FMMSEParser>>run
		startpc: 	72
		numArgs: 	1


[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :bar | 
progBar := bar.
self basicRun ]
		currentValue: 	3923425
		min: 	1
		max: 	9131435
		title: 	'Parsing model.mse'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OrderedCollection>>at:put:


BlockClosure>>on:do:
	Receiver: [ result := block cull: self ]
	Arguments and temporary variables: 
		exception: 	JobNotification
		handlerAction: 	[ :notification | notification handle: self ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[ 
self prepareForRunning.
[ result := block cull: self ]
	on: Jo...etc...
		startpc: 	57
		numArgs: 	0


[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :bar | 
progBar := bar.
self basicRun ]
		currentValue: 	3923425
		min: 	1
		max: 	9131435
		title: 	'Parsing model.mse'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OrderedCollection>>at:put:


BlockClosure>>ensure:
	Receiver: [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :not...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	49
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		block: 	[ :bar | 
progBar := bar.
self basicRun ]
		currentValue: 	3923425
		min: 	1
		max: 	9131435
		title: 	'Parsing model.mse'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OrderedCollection>>at:put:


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Parsing model.mse'
		minVal: 	1
		maxVal: 	9131435
		workBlock: 	[ :bar | 
progBar := bar.
self basicRun ]
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


MorphicUIManager(UIManager)>>displayProgress:at:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Parsing model.mse'
		aPoint: 	(630@668)
		minVal: 	1
		maxVal: 	9131435
		workBlock: 	[ :bar | 
progBar := bar.
self basicRun ]
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


FMMSEParser>>run
	Receiver: a FMMSEParser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		client: 	a MSEImporter
		buf: 	a WriteStream
		char: 	$)
		progBar: 	a Job
		increments: 	22751


MSEImporter(FMImporter)>>run
	Receiver: a MSEImporter
	Arguments and temporary variables: 
		parser: 	a FMMSEParser
	Receiver's instance variables: 
		stack: 	a Stack(a FMFutureElement)
		elements: 	an OrderedCollection(UndoableCommandTest>>testCommandNotExecutable() ...etc...
		model: 	a FMRepository
		metamodel: 	a FMMetaRepository
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		tally: 	30088
		reminderDict: 	an IdentityDictionary(size 12423)
		serialDict: 	an IdentityDictionary(size 22752)


MooseModel class>>importFrom:withMetamodel:
	Receiver: MooseModel
	Arguments and temporary variables: 
		aStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
		aMetamodel: 	a FMMetaRepository
		tower: 	a FMCompleteTower
		importer: 	a MSEImporter
	Receiver's instance variables: 
		superclass: 	MooseAbstractGroup
		methodDict: 	a MethodDictionary(#add:->MooseModel>>#add: #add:asBookmark:->Moose...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceLanguage #name)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MooseModel
		classPool: 	a Dictionary(#MostRecentOwner->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Moose-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		mooseSubClasses: 	nil
		mostRecentOwner: 	nil
		rootModel: 	a MooseModel #Root(5)
		metaTower: 	a FMCompleteTower


MooseModel class>>importFrom:
	Receiver: MooseModel
	Arguments and temporary variables: 
		aStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
	Receiver's instance variables: 
		superclass: 	MooseAbstractGroup
		methodDict: 	a MethodDictionary(#add:->MooseModel>>#add: #add:asBookmark:->Moose...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceLanguage #name)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MooseModel
		classPool: 	a Dictionary(#MostRecentOwner->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Moose-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		mooseSubClasses: 	nil
		mostRecentOwner: 	nil
		rootModel: 	a MooseModel #Root(5)
		metaTower: 	a FMCompleteTower


MooseModel>>importFromMSEStream:
	Receiver: a MooseModel #noname(0)
	Arguments and temporary variables: 
		aStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
		repository: 	nil
	Receiver's instance variables: 
		mooseID: 	263522
		state: 	a MooseDefaultState
		storage: 	a MooseGroupRuntimeStorage()
		sourceLanguage: 	nil
		name: 	#noname


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		result: 	nil
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
		mooseModel: 	a MooseModel #noname(0)
		hasDependency: 	nil
		printResult: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'| stream mooseModel  result hasDependency printResult | 
moose...etc...
		itsSelection: 	a Text for '| stream mooseModel  result hasDependency printResult...etc...
		itsSelectionString: 	'| stream mooseModel  result hasDependency printResult | 
m...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| stream mooseModel result hasDependency printResult |
	mooseModel :...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(287834112)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(287834112)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(456654848)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(285.0@157.0) corner: (1747.0@1047.0)
		owner: 	a SystemWindow(262668288)
		submorphs: 	an Array(a TransformMorph(89391104))
		fullBounds: 	(285@157) corner: (1747@1047)
		color: 	NewColor white
		extension: 	a MorphExtension (266600448) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(496500736)
		scroller: 	a TransformMorph(89391104)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(819986432)
		textMorph: 	a TextMorphForEditView(287834112)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 968)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(456654848)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(285.0@157.0) corner: (1747.0@1047.0)
		owner: 	a SystemWindow(262668288)
		submorphs: 	an Array(a TransformMorph(89391104))
		fullBounds: 	(285@157) corner: (1747@1047)
		color: 	NewColor white
		extension: 	a MorphExtension (266600448) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(496500736)
		scroller: 	a TransformMorph(89391104)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(819986432)
		textMorph: 	a TextMorphForEditView(287834112)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 968)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(287834112)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1456@553)
		owner: 	a TransformMorph(89391104)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1456@553)
		color: 	NewColor black
		extension: 	a MorphExtension (324534272) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor black
		textStyle: 	a TextStyle Source Code Pro
		text: 	a Text for '| stream mooseModel  result hasDependency printResult | 
moos...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: NewColor black
		editView: 	a PluggableTextMorph(456654848)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(456654848)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(285.0@157.0) corner: (1747.0@1047.0)
		owner: 	a SystemWindow(262668288)
		submorphs: 	an Array(a TransformMorph(89391104))
		fullBounds: 	(285@157) corner: (1747@1047)
		color: 	NewColor white
		extension: 	a MorphExtension (266600448) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(496500736)
		scroller: 	a TransformMorph(89391104)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(819986432)
		textMorph: 	a TextMorphForEditView(287834112)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 968)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(456654848)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(285.0@157.0) corner: (1747.0@1047.0)
		owner: 	a SystemWindow(262668288)
		submorphs: 	an Array(a TransformMorph(89391104))
		fullBounds: 	(285@157) corner: (1747@1047)
		color: 	NewColor white
		extension: 	a MorphExtension (266600448) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	NewColor white
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(496500736)
		scroller: 	a TransformMorph(89391104)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(819986432)
		textMorph: 	a TextMorphForEditView(287834112)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 968)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(456654848)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{GLMSmalltalkEditor}
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(456654848)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(456654848)
		secondArg: 	a PluggableTextMorph(456654848)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(456654848)
		secondArg: 	a PluggableTextMorph(456654848)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(456654848)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(456654848)



--- The full stack ---
OrderedCollection>>at:put:
FMDanglingReference>>resolve:
[ :each | 
each resolve: element.
tally := tally - 1.
tally should >= 0 ] in MSEImporter(FMImporter)>>assign:to:
OrderedCollection>>do:
MSEImporter(FMImporter)>>assign:to:
FMFutureElement>>serial:
MSEImporter(FMImporter)>>serial:
FMMSEParser>>Serial
FMMSEParser>>Element
FMMSEParser>>Document
FMMSEParser>>basicRun
[ :bar | 
progBar := bar.
self basicRun ] in FMMSEParser>>run
BlockClosure>>cull:
[ result := block cull: self ] in [ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>on:do:
[ 
self prepareForRunning.
[ result := block cull: self ]
	on: JobNotification
	do: [ :notification | notification handle: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager(UIManager)>>displayProgress:at:from:to:during:
FMMSEParser>>run
MSEImporter(FMImporter)>>run
MooseModel class>>importFrom:withMetamodel:
MooseModel class>>importFrom:
MooseModel>>importFromMSEStream:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
FileDoesNotExist: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/buildSTMooseModelInstall.st
30 January 2015 6:18:54.805949 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

FileHandle>>streamError
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/mo...etc...
		writable: 	false
		id: 	nil


FileHandle>>readStream
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/mo...etc...
		writable: 	false
		id: 	nil


FileSystem>>readStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' /...etc...
	Receiver's instance variables: 
		workingDirectory: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dic...etc...
		store: 	a MacStore


FileReference>>readStream
	Receiver: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/buildSTMooseModelI...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' / 'curre...etc...


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/buildSTMooseModelI...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :stream | 
self
	handleErrorsDuring: [ 
		codeImporter := CodeImporte...etc...
		stream: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' / 'curre...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	nil
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/m...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/mo...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moo...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/too...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'buildSTMooseModelInstall.st'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
FileHandle>>streamError
FileHandle>>readStream
FileSystem>>readStreamOn:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

THERE_BE_DRAGONS_HERE
FileDoesNotExist: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/buildSTMooseModelInstall.st
30 January 2015 6:20:15.570346 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

FileHandle>>streamError
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/mo...etc...
		writable: 	false
		id: 	nil


FileHandle>>readStream
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/mo...etc...
		writable: 	false
		id: 	nil


FileSystem>>readStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' /...etc...
	Receiver's instance variables: 
		workingDirectory: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dic...etc...
		store: 	a MacStore


FileReference>>readStream
	Receiver: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/buildSTMooseModelI...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' / 'curre...etc...


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/buildSTMooseModelI...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :stream | 
self
	handleErrorsDuring: [ 
		codeImporter := CodeImporte...etc...
		stream: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' / 'curre...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	nil
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/m...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/mo...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moo...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/too...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'buildSTMooseModelInstall.st'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
FileHandle>>streamError
FileHandle>>readStream
FileSystem>>readStreamOn:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

THERE_BE_DRAGONS_HERE
FileDoesNotExist: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine+buildSTMooseModelInstall.st
30 January 2015 6:21:44.720882 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

FileHandle>>streamError
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
		writable: 	false
		id: 	nil


FileHandle>>readStream
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
		writable: 	false
		id: 	nil


FileSystem>>readStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' /...etc...
	Receiver's instance variables: 
		workingDirectory: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dic...etc...
		store: 	a MacStore


FileReference>>readStream
	Receiver: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine+buildSTMooseModel...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' / 'curre...etc...


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine+buildSTMooseModel...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :stream | 
self
	handleErrorsDuring: [ 
		codeImporter := CodeImporte...etc...
		stream: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' / 'curre...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	nil
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-eng...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dic...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine+bui...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
FileHandle>>streamError
FileHandle>>readStream
FileSystem>>readStreamOn:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

THERE_BE_DRAGONS_HERE
FileDoesNotExist: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-enginebuildSTMooseModelInstall.st
30 January 2015 6:21:55.152636 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

FileHandle>>streamError
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
		writable: 	false
		id: 	nil


FileHandle>>readStream
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
		writable: 	false
		id: 	nil


FileSystem>>readStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' /...etc...
	Receiver's instance variables: 
		workingDirectory: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dic...etc...
		store: 	a MacStore


FileReference>>readStream
	Receiver: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-enginebuildSTMooseModelI...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' / 'curre...etc...


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-enginebuildSTMooseModelI...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :stream | 
self
	handleErrorsDuring: [ 
		codeImporter := CodeImporte...etc...
		stream: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'caracciolo' / 'Current' / 'Projects' / 'Dicto' / 'curre...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	nil
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-eng...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dic...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-enginebuil...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
FileHandle>>streamError
FileHandle>>readStream
FileSystem>>readStreamOn:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/buildSTMooseModelInstall.st
===============================================================================
THERE_BE_DRAGONS_HERE
An attempt to use interactive tools detected, while in non-interactive mode
	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/analysis/DictoTestSuite/model.mse'
30 January 2015 6:22:16.239963 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

NonInteractiveUIManager>>nonInteractive:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		anException: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dic...etc...
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		anException: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dic...etc...
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


FileDoesNotExistException>>defaultAction
	Receiver: FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/ana...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/analysis/...etc...
		readOnly: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
	Receiver's instance variables: 
nil

MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ aCommandLinehandler activateWith: commandLine ]


FileDoesNotExistException(Exception)>>pass
	Receiver: FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/ana...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/analysis/...etc...
		readOnly: 	nil


STCommandLineHandler>>handleError:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		error: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/cur...etc...
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		fileReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dict...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :e | self handleError: e reference: aReference ] in STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		e: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>cull:
	Receiver: [ :e | self handleError: e reference: aReference ]
	Arguments and temporary variables: 
		anArg: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/cur...etc...
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>handleErrorsDuring:reference:
		startpc: 	48
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	STCommandLineHandler>>handleErrorsDuring:reference:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ codeImporter evaluate ]


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	STCommandLineHandler>>handleErrorsDuring:reference:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ codeImporter evaluate ]


FileDoesNotExistException(Exception)>>signal
	Receiver: FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/ana...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/analysis/...etc...
		readOnly: 	nil


MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'../analysis/DictoTestSuite/model.mse'
		dir: 	nil
		localName: 	nil
		fullName: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/analysis/...etc...
		f: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'../analysis/DictoTestSuite/model.mse'
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: #stderr #Stdin->nil #Stdi...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		model: 	a MooseModel #DictoModel(9234)
		importer: 	a MoosePharoImporterTask
		stream: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| model importer stream |
	Gofer new
		url: 'http://smalltalkhub.com...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smalltalkhub.com/mc/carac...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'|model importer stream|
Gofer new url: ''http://smalltalkhub.com/mc/...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(|model importer stream|
Gofer new url: 'http://s...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smal...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(|model importer stream|
Gofer new url: 'http:...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-eng...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dic...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/bui...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver



--- The full stack ---
NonInteractiveUIManager>>nonInteractive:
NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
FileDoesNotExistException>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
FileDoesNotExistException(Exception)>>pass
STCommandLineHandler>>handleError:reference:
[ :e | self handleError: e reference: aReference ] in STCommandLineHandler>>handleErrorsDuring:reference:
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
FileDoesNotExistException(Exception)>>signal
MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
FileStream class>>forceNewFileNamed:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
ErrorNonInteractive>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
ErrorNonInteractive(Exception)>>signal
ErrorNonInteractive class>>signalForException:
NonInteractiveUIManager>>nonInteractive:
NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
FileDoesNotExistException>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[ self idleProcess ] in ProcessorScheduler class>>startUp
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/buildSTMooseModelInstall.st
===============================================================================
THERE_BE_DRAGONS_HERE
An attempt to use interactive tools detected, while in non-interactive mode
	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/analysis/DictoTestSuite/model.mse'
30 January 2015 6:23:42.041918 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

NonInteractiveUIManager>>nonInteractive:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		anException: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dic...etc...
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		anException: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dic...etc...
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


FileDoesNotExistException>>defaultAction
	Receiver: FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moo...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/ana...etc...
		readOnly: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
	Receiver's instance variables: 
nil

MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ aCommandLinehandler activateWith: commandLine ]


FileDoesNotExistException(Exception)>>pass
	Receiver: FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moo...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/ana...etc...
		readOnly: 	nil


STCommandLineHandler>>handleError:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		error: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/cur...etc...
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		fileReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dict...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :e | self handleError: e reference: aReference ] in STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		e: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>cull:
	Receiver: [ :e | self handleError: e reference: aReference ]
	Arguments and temporary variables: 
		anArg: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/cur...etc...
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>handleErrorsDuring:reference:
		startpc: 	48
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	STCommandLineHandler>>handleErrorsDuring:reference:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ codeImporter evaluate ]


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	STCommandLineHandler>>handleErrorsDuring:reference:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ codeImporter evaluate ]


FileDoesNotExistException(Exception)>>signal
	Receiver: FileDoesNotExistException: '/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moo...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/ana...etc...
		readOnly: 	nil


MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'../../analysis/DictoTestSuite/model.mse'
		dir: 	nil
		localName: 	nil
		fullName: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/tools/moose/ana...etc...
		f: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'../../analysis/DictoTestSuite/model.mse'
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: #stderr #Stdin->nil #Stdi...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		model: 	a MooseModel #DictoModel(9234)
		importer: 	a MoosePharoImporterTask
		stream: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| model importer stream |
	Gofer new
		url: 'http://smalltalkhub.com...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smalltalkhub.com/mc/carac...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'|model importer stream|
Gofer new url: ''http://smalltalkhub.com/mc/...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(|model importer stream|
Gofer new url: 'http://s...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smal...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(|model importer stream|
Gofer new url: 'http:...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-eng...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dic...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/bui...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver



--- The full stack ---
NonInteractiveUIManager>>nonInteractive:
NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
FileDoesNotExistException>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
FileDoesNotExistException(Exception)>>pass
STCommandLineHandler>>handleError:reference:
[ :e | self handleError: e reference: aReference ] in STCommandLineHandler>>handleErrorsDuring:reference:
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
FileDoesNotExistException(Exception)>>signal
MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
FileStream class>>forceNewFileNamed:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
ErrorNonInteractive>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
ErrorNonInteractive(Exception)>>signal
ErrorNonInteractive class>>signalForException:
NonInteractiveUIManager>>nonInteractive:
NonInteractiveUIManager>>fileDoesNotExistsDefaultAction:
FileDoesNotExistException>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[ self idleProcess ] in ProcessorScheduler class>>startUp
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/buildSTMooseModelInstall.st
===============================================================================
THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MultiByteFileStream>>WorldState
30 January 2015 6:25:01.507486 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

MultiByteFileStream(Object)>>doesNotUnderstand: #WorldState
	Receiver: MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoT...etc...
	Arguments and temporary variables: 
		aMessage: 	WorldState
		exception: 	MessageNotUnderstood: MultiByteFileStream>>WorldState
		resumeValue: 	nil
	Receiver's instance variables: 



UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		model: 	a MooseModel #DictoModel(9234)
		importer: 	a MoosePharoImporterTask
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| model importer stream |
	Gofer new
		url: 'http://smalltalkhub.com...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smalltalkhub.com/mc/carac...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'|model importer stream|
Gofer new url: ''http://smalltalkhub.com/mc/...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(|model importer stream|
Gofer new url: 'http://s...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smal...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(|model importer stream|
Gofer new url: 'http:...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-eng...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dic...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/bui...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MultiByteFileStream(Object)>>doesNotUnderstand: #WorldState
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[ self idleProcess ] in ProcessorScheduler class>>startUp
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/buildSTMooseModelInstall.st
===============================================================================
THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MultiByteFileStream>>WorldState
30 January 2015 6:26:04.445185 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

MultiByteFileStream(Object)>>doesNotUnderstand: #WorldState
	Receiver: MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/bin/analysis/DictoT...etc...
	Arguments and temporary variables: 
		aMessage: 	WorldState
		exception: 	MessageNotUnderstood: MultiByteFileStream>>WorldState
		resumeValue: 	nil
	Receiver's instance variables: 



UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		model: 	a MooseModel #DictoModel(9234)
		importer: 	a MoosePharoImporterTask
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| model importer stream |
	Gofer new
		url: 'http://smalltalkhub.com...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smalltalkhub.com/mc/carac...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'|model importer stream|
Gofer new url: ''http://smalltalkhub.com/mc/...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(|model importer stream|
Gofer new url: 'http://s...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smal...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(|model importer stream|
Gofer new url: 'http:...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-eng...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dic...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/bui...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MultiByteFileStream(Object)>>doesNotUnderstand: #WorldState
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[ self idleProcess ] in ProcessorScheduler class>>startUp
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/buildSTMooseModelInstall.st
===============================================================================
THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "entities" is nil
30 January 2015 6:28:01.071093 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

UndefinedObject(Object)>>doesNotUnderstand: #entities
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	entities
		exception: 	MessageNotUnderstood: receiver of "entities" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MooseModel class>>export:withMetamodel:to:
	Receiver: MooseModel
	Arguments and temporary variables: 
		aModel: 	nil
		aMetamodel: 	a FMMetaRepository
		aStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
		tower: 	a FMCompleteTower
		repository: 	nil
	Receiver's instance variables: 
		superclass: 	MooseAbstractGroup
		methodDict: 	a MethodDictionary(#add:->MooseModel>>#add: #add:asBookmark:->Moose...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceLanguage #name)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MooseModel
		classPool: 	a Dictionary(#MostRecentOwner->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Moose-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		mooseSubClasses: 	nil
		mostRecentOwner: 	nil
		rootModel: 	a MooseModel #Root(1)
		metaTower: 	a FMCompleteTower


MooseModel class>>export:to:
	Receiver: MooseModel
	Arguments and temporary variables: 
		aModel: 	nil
		aStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
	Receiver's instance variables: 
		superclass: 	MooseAbstractGroup
		methodDict: 	a MethodDictionary(#add:->MooseModel>>#add: #add:asBookmark:->Moose...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceLanguage #name)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MooseModel
		classPool: 	a Dictionary(#MostRecentOwner->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Moose-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		mooseSubClasses: 	nil
		mostRecentOwner: 	nil
		rootModel: 	a MooseModel #Root(1)
		metaTower: 	a FMCompleteTower


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		model: 	a MooseModel #DictoModel(9234)
		importer: 	a MoosePharoImporterTask
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| model importer stream |
	Gofer new
		url: 'http://smalltalkhub.com...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smalltalkhub.com/mc/carac...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'|model importer stream|
Gofer new url: ''http://smalltalkhub.com/mc/...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(|model importer stream|
Gofer new url: 'http://s...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smal...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(|model importer stream|
Gofer new url: 'http:...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-eng...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dic...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/bui...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #entities
MooseModel class>>export:withMetamodel:to:
MooseModel class>>export:to:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[ self idleProcess ] in ProcessorScheduler class>>startUp
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------


===============================================================================
Notice: Errors in script loaded from /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/buildSTMooseModelInstall.st
===============================================================================
THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "entities" is nil
30 January 2015 6:29:38.053498 pm

VM: Mac OS - intel - 1091 - NBCoInterpreter NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
NBCogit NativeBoost-CogPlugin-EstebanLorenzano.21 uuid: 4d9b9bdf-2dfa-4c0b-99eb-5b110dadc697 Jan  1 2015
https://github.com/pharo-project/pharo-vm.git Commit: 4a0d556150d478ff2de3c9624d2f18e6eaa3fa5c Date: 2014-12-18 18:42:53 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14888

Image: Pharo3.0 [Latest update: #30767]

UndefinedObject(Object)>>doesNotUnderstand: #entities
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	entities
		exception: 	MessageNotUnderstood: receiver of "entities" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MooseModel class>>export:withMetamodel:to:
	Receiver: MooseModel
	Arguments and temporary variables: 
		aModel: 	nil
		aMetamodel: 	a FMMetaRepository
		aStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
		tower: 	a FMCompleteTower
		repository: 	nil
	Receiver's instance variables: 
		superclass: 	MooseAbstractGroup
		methodDict: 	a MethodDictionary(#add:->MooseModel>>#add: #add:asBookmark:->Moose...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceLanguage #name)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MooseModel
		classPool: 	a Dictionary(#MostRecentOwner->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Moose-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		mooseSubClasses: 	nil
		mostRecentOwner: 	nil
		rootModel: 	a MooseModel #Root(1)
		metaTower: 	a FMCompleteTower


MooseModel class>>export:to:
	Receiver: MooseModel
	Arguments and temporary variables: 
		aModel: 	nil
		aStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current...etc...
	Receiver's instance variables: 
		superclass: 	MooseAbstractGroup
		methodDict: 	a MethodDictionary(#add:->MooseModel>>#add: #add:asBookmark:->Moose...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceLanguage #name)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MooseModel
		classPool: 	a Dictionary(#MostRecentOwner->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Moose-Core'
		traitComposition: 	{}
		localSelectors: 	nil
		mooseSubClasses: 	nil
		mostRecentOwner: 	nil
		rootModel: 	a MooseModel #Root(1)
		metaTower: 	a FMCompleteTower


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		model: 	a MooseModel #DictoModel(9234)
		importer: 	a MoosePharoImporterTask
		stream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/current/...etc...
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| model importer stream |
	Gofer new
		url: 'http://smalltalkhub.com...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smalltalkhub.com/mc/carac...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'|model importer stream|
Gofer new url: ''http://smalltalkhub.com/mc/...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(|model importer stream|
Gofer new url: 'http://s...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(|model importer stream|
Gofer new url: 'http://smal...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(|model importer stream|
Gofer new url: 'http:...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: '/Users/caracciolo/Current/Projects/Dicto/curr...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(|model importer stream...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-e...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-en...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-eng...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ /Users/caracciolo/Current/Projects/Dicto/current/bin/dic...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ /Users/caracciolo/Current/Projects/Dic...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'/Users/caracciolo/Current/Projects/Dicto/current/bin/dicto-engine/bui...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLine'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11584
		lastStepMessage: 	nil
		lastCycleTime: 	14189
		alarms: 	a Heap()
		lastAlarmTime: 	14169
		menuBuilder: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an ImageMorph(544997376))
		fullBounds: 	nil
		color: 	NewColor white
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	a ThreadSafeTranscript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #entities
MooseModel class>>export:withMetamodel:to:
MooseModel class>>export:to:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ 
				(ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ 
logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ 
Smalltalk logError: aString inContext: aContext.	" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ 
						(ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
[ :class | class default unhandledErrorDefaultAction: self exception ] in UnhandledError>>defaultAction
[ :v | ^ oneArgBlock value: v ] in SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
BlockClosure>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[ self runTimerEventLoop ] in Delay class>>startTimerEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[ self idleProcess ] in ProcessorScheduler class>>startUp
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] in [ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
BlockClosure>>repeat
[ 
[ 
event wait.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self changed: #childProcessStatus ] repeat ] in UnixOSProcessAccessor>>grimReaperProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

